<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haijd&#39;s Blog</title>
    <link>/</link>
    <description>Recent content on Haijd&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 29 Jun 2019 14:46:11 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>WSL&#43;VSCODE体验UBUNTU环境下的开发</title>
      <link>/tool/wsl&#43;vscode%E4%BD%93%E9%AA%8Cubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%BC%80%E5%8F%91/</link>
      <pubDate>Sat, 29 Jun 2019 14:46:11 +0800</pubDate>
      
      <guid>/tool/wsl&#43;vscode%E4%BD%93%E9%AA%8Cubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%BC%80%E5%8F%91/</guid>
      <description>配置 WSL 环境 首先安装 WSL，我这里选择的是 ubuntu18.04 这个应用。
切换 WSL 的默认用户为 root 用户 切换成 root 用户主要是避免后续开发中遇到权限问题比较麻烦，直接默认 root 解决问题。
找到ubuntu安装目录，一般在C:\Program Files\WindowsApps\CanonicalGroupLimited.Ubuntu18.04onWindows_1804.2019.522.0_x64__79rhkp1fndgsc文件夹下面。
在文件夹中打开 powershell 运行下面的命令：
1 2 3 4  ./ubuntu1804.exe config --default-user root # 重启WSL服务 net stop LxssManager net start LxssManager   如果显示拒绝访问，就用管理员权限打开 powershell，或者直接在资源管理器中找到LxssManager这个服务重新启动。
切换 apt 源为清华源 默认的软件源下载太慢，替换为国内的清华大学软件源。
Ubuntu 清华源的地址：https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/
切换 WSL 默认的 shell 为 zsh zsh 的优点在我看来就是配置丰富，最重要的就是好看。
执行下面的命令安装zsh和oh-my-zsh
1 2 3  sudo apt-get update sudo apt-get install zsh sh -c &amp;#34;$(wget https://raw.</description>
    </item>
    
    <item>
      <title>Win10&#43;WSL配置Golang开发环境</title>
      <link>/golang/win10&#43;wsl%E9%85%8D%E7%BD%AEgolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sat, 20 Apr 2019 22:08:09 +0800</pubDate>
      
      <guid>/golang/win10&#43;wsl%E9%85%8D%E7%BD%AEgolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>Linux 是比较理想的开发环境，先前电脑装的 Ubuntu 系统，流畅度、字体效果感觉都比 Windows 好，但是开发之外其他的内容就很难在 Linux 上进行了，例如印象笔记、微信 QQ 传输文件等，最近又换回了 Windows 系统，花时间借助 win10 的 Linux 子系统也能搭一个 Linux 下的开发环境。
安装 WSL 关于如何安装 WSL 的操作就省略了，Google 一下很多，也很简单，主要介绍一下其他的配置内容。
配置清华大学软件源 Ubuntu 官方阿软件源服务器在国外，执行apt-get比较慢，所以切换为国内的软件源进行加速，这里使用清华大学开源软件镜像站提供的 Ubuntu 镜像
Hyper 好看是第一生产力，Hyper 是一个第三方的命令行工具，使用Electron框架开发的，可配置性很高，有丰富的主题可以选择，直接秒杀自带的黑框框，来两张图对比一下： 安装 Hyper 直接上官网下载对应的版本安装即可。
配置 Hyper 默认为 WSL 的 terminal 打开 Hyper 窗口，在左上角菜单选择 Eidt -&amp;gt; Perferences&amp;hellip; 后会直接打开配置文件，配置文件是 js 文件很容易看懂。 我们主要修改shell这个属性的值，这个配置可以修改 Hyper 默认使用的 terminal 类型，我们输入wsl的路径：
1 2 3  shell: &amp;#39;C:\\Windows\\System32\\wsl.exe&amp;#39;, ... shellArgs: [&amp;#39;bash&amp;#39;], // 这是进入terminal时默认命令，可以酌情修改   修改完之后保存配置文件，Hyper 会热加载配置，不过重启一下最好。</description>
    </item>
    
    <item>
      <title>使用map、reduce和filter简化你的JavaScript代码库</title>
      <link>/frontend/%E4%BD%BF%E7%94%A8mapreduce%E5%92%8Cfilter%E7%AE%80%E5%8C%96%E4%BD%A0%E7%9A%84javascript%E4%BB%A3%E7%A0%81%E5%BA%93/</link>
      <pubDate>Sun, 24 Feb 2019 12:02:52 +0800</pubDate>
      
      <guid>/frontend/%E4%BD%BF%E7%94%A8mapreduce%E5%92%8Cfilter%E7%AE%80%E5%8C%96%E4%BD%A0%E7%9A%84javascript%E4%BB%A3%E7%A0%81%E5%BA%93/</guid>
      <description>原文：How to simplify your codebase with map(), reduce(), and filter() in JavaScript
 当你查阅有关于Array.reduce的资料以及它的用法有多酷以外，在很多资料中唯一的例子就是关于“数字之和”的示例，这对于我们了解Array.reduce的定义来说不是很有用。
此外，我也从来没有在真实的代码库中看到有使用它。但是我经常能看到一个7-8行的for循环代码解决的常规任务，使用Array.reduce只用一行就搞定了。
如果你有map、reduce函数更好的使用方式，请在文章评论区回复。
1. 从strings/numbers数组中去重 这是这篇文章中唯一不关于map/reduce/filter函数的使用方法，但是这个方法很有用，很难从这篇文章中排除，而且也会在后面的例子中用到。
1 2 3 4 5  const values = [3, 1, 3, 5, 2, 4, 4, 4]; const uniqueValues = [...new Set(values)]; // uniqueValues 等于 [3, 1, 5, 2, 4]    2. 简单查找（大小写敏感） filter()函数会创建一个新的数组，在下面的例子中新的数组将包含测试数组中符合条件的子项。
1 2 3 4 5 6 7 8 9 10  const users = [ { id: 11, name: &amp;#39;Adam&amp;#39;, age: 23, group: &amp;#39;editor&amp;#39; }, { id: 47, name: &amp;#39;John&amp;#39;, age: 28, group: &amp;#39;admin&amp;#39; }, { id: 85, name: &amp;#39;William&amp;#39;, age: 34, group: &amp;#39;editor&amp;#39; }, { id: 97, name: &amp;#39;Oliver&amp;#39;, age: 28, group: &amp;#39;admin&amp;#39; } ]; let res = users.</description>
    </item>
    
    <item>
      <title>6个Angular开发者必备的VSCode扩展</title>
      <link>/frontend/6%E4%B8%AAangular%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E5%A4%87%E7%9A%84vscode%E6%89%A9%E5%B1%95/</link>
      <pubDate>Thu, 21 Feb 2019 22:02:17 +0800</pubDate>
      
      <guid>/frontend/6%E4%B8%AAangular%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E5%A4%87%E7%9A%84vscode%E6%89%A9%E5%B1%95/</guid>
      <description>在这篇文章，我将推荐6个我认为是使用VSCode开发Angular必备的扩展，如果你有喜欢的有用插件，也请推荐给我😁。
1. 扩展推荐 1.1. TypeScript Hero 这是一个非常有用的插件，可以帮助你自动管理你的TypeScript import，当你复制一段代码是，TypeScript Hero会自动感知其中需要import的类型，并且自动import进来。有效节省你的时间。
其他有用的功能包括排序、删除无用的import等。
1.2. Angular Language Service 这个插件为Angular Template编辑提供了丰富的功能支持。假设你有一个Component如下：
1 2 3 4 5 6  course = { title: &amp;#39;The Complete Angular Course&amp;#39;, author: { name: &amp;#39;Mosh Hamedani&amp;#39; } }    借助这个插件，你可以很方便的编辑你的Template: 1.3. Bracket Pair Colorizer 这个插件可以使用不同的颜色来标记不同类型的括号： 1.4. Move TS 随着你的项目的发展，也许你想要将你的modules分解的更小、更容易维护。这时你必须移动文件还有文件夹，但是有个问题是移动文件和文件夹后，路径会改变，原先所有import它们的地方将失效，这时可能每个文件的import需要一个一个手动处理。
使用Move TS扩展，可以自动的帮助你管理移动文件和文件夹后的import。
1.5. Material Icon Theme 一个Material风格的项目文件资源管理器图标主题。
1.6. Angular TypeScript Snippets 另一个John Papa开发的有用扩展，可以在开发Angular项目时提高你的工作效率。
这个插件包含了大量的代码段，可以帮助你快速生成代码，免去重复的码字过程。代码段覆盖了component、service、directive、template等等组件，它的可以给你提供如下的快捷代码段生成： 2. 参考资料 https://morioh.com/p/0e54a8cff696/6-essential-vscode-extensions-for-angular-developers</description>
    </item>
    
    <item>
      <title>初探System.Threading.Channels</title>
      <link>/csharp/%E5%88%9D%E6%8E%A2system.threading.channels/</link>
      <pubDate>Tue, 19 Feb 2019 21:29:51 +0800</pubDate>
      
      <guid>/csharp/%E5%88%9D%E6%8E%A2system.threading.channels/</guid>
      <description>最近再次看了一下C#并发编程的一些资料，对其中的Rx产生了一些兴趣和疑问，同时想起对比一下Go语言的并发特性，所以查阅了一些资料，今天谈谈一个新的并发操作类库System.Threading.Channels。
1. 简介 System.Threading.Channels是.Net Core基础类库中实现的一个多线程相关的库，专门处理数据流相关的操作，用来在生产者和订阅者之间传递数据（不知道可不可以理解为线程间传递数据，我把它类比成了Go语言中的Channel），使用时需要通过NuGet安装。
这个库的前身是System.Threading.Tasks.Channels，来自实验性质的核心类库项目https://github.com/dotnet/corefxlab，但是在2017年9月就不再更新了，目前使用的话需要用到最新的System.Threading.Channels库，如果你也是第一次接触的话，就直接上手研究System.Threading.Channels就可以了。
Channel API操作基于Channel对象，其操作主要由ChannelReader和ChannelWriter两部分组成，由Channelt提供的工厂方法创建一个有容量限制（或者无限制、最大容量限制）的channel。这点类似于Go语言中的chan的容量，二者在这里有很多的类似的地方，也有不同的地方。
1.1. 和Go语言channel的一些比较 Go语言中的channel默认是没有容量的，在使用这个没有容量的channel时，生产者和消费者必须“流动”起来，否则将会阻塞，也就是当生产者写入channel一个数据时，必须同时有一个接收者接收，否则写入操作会停止，等待有一个消费者取走channel中的数据，写入操作才会继续。
在System.Threading.Channels库中，没有类似Go语言的默认容量的机制，需要按需调用不同的Channel对象：
 public static Channel&amp;lt;T&amp;gt; CreateBounded&amp;lt;T&amp;gt;(int capacity); ：可以创建一个带有容量限制的Channel实例对象。 public static Channel&amp;lt;T&amp;gt; CreateBounded&amp;lt;T&amp;gt;(BoundedChannelOptions options) ：创建一个自定义配置的Channel实例对象，可配置容量、以及在接收到新数据时的操作模式等等：  BoundedChannelFullMode.Wait：等待当前写入完成 BoundedChannelFullMode.DropNewest：删除并忽略管道中写入的最新的数据 BoundedChannelFullMode.DropOldest：删除并忽略管道中最旧的数据 BoundedChannelFullMode.DropWrite：删除当前正在写的数据，以写入管道中的新数据  public static Channel&amp;lt;T&amp;gt; CreateUnbounded&amp;lt;T&amp;gt;(); ：创建一个没有容量限制的Channel实例对象，在实际使用时应当谨慎使用该创建方式，因为可能会发生OutOfMemoryException。 public static Channel&amp;lt;T&amp;gt; CreateUnbounded&amp;lt;T&amp;gt;(UnboundedChannelOptions options)：创建一个自定义配置的没有容量限制的Channel实例对象。该配置选项因为没有容量限制所以不会有写入等待操作模式，只有默认的一些配置：  public bool SingleWriter { get; set; }：是否需要一个一个读 public bool SingleReader { get; set; }：是否需要一个一个写 public bool AllowSynchronousContinuations { get; set; }：是否需要异步连续操作（我个人理解为异步操作时同时进行读写）   Go语言的channel机制和System.Threading.Channels的不同之处有两个：
 Go语言没有无限容量的channel，而且就我个人的想法而言，无限容量并不“无限”，因为内存是有限的。 System.Threading.Channels没有单向的channel类型。在Go中可以创建“只读”或者“只写”的channel，但是System.Threading.Channels中没有提供这种操作。  1.</description>
    </item>
    
    <item>
      <title>Gitlab&#43;Jenkins实现CI/CD</title>
      <link>/devops/gitlab&#43;jenkins%E5%AE%9E%E7%8E%B0cicd/</link>
      <pubDate>Sun, 10 Feb 2019 14:00:48 +0800</pubDate>
      
      <guid>/devops/gitlab&#43;jenkins%E5%AE%9E%E7%8E%B0cicd/</guid>
      <description>概述 在这篇文章中，演示一个简单的持续集成的案例，使用Windows的Linux子系统部署Gitlab和Jenkins，实现一套自动测试、自动部署的系统，本次的内容没有涉及到Docker部署，下一篇文章将介绍全部使用Docker部署的持续集成。
系统 安装部署使用的系统为Windows下的Linux子系统，具体的系统信息： 安装Jenkins 安装到Ubuntu系统 安装repository key到操作系统：
1  wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -   添加包源到sources.list中：
1  sudo sh -c &amp;#39;echo deb http://pkg.jenkins.io/debian-stable binary/ &amp;gt; /etc/apt/sources.list.d/jenkins.list&amp;#39;   更新apt新仓库
1  sudo apt update   最后安装Jenkins
1  sudo apt install jenkins   启动jenkins
1  sudo service jenkins start   如果显示[OK]那么说明Jenkins启动成功了，Jenkins不需要数据库，所以现在可以直接在浏览器中浏览了，在浏览器中打开地址http://your-domian:8080。
配置Jenkins 第一步会提示输入一段密钥： 直接按照提示打开该文件即可：
1  sudo vi /var/lib/jenkins/secrets/initialAdminPassword   如果提示没有权限，则需要将该文件的权限赋予当前的用户：</description>
    </item>
    
    <item>
      <title>在.Net Core中实现一个WebSocket路由</title>
      <link>/csharp/%E5%9C%A8.net-core%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAwebsocket%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Sun, 27 Jan 2019 17:41:16 +0800</pubDate>
      
      <guid>/csharp/%E5%9C%A8.net-core%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAwebsocket%E8%B7%AF%E7%94%B1/</guid>
      <description>.Net Core中使用WebSocket默认是没有路由系统的，只能通过Request.Path==&amp;quot;/xxx&amp;quot;来判断请求，例如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  app.Use(async (context, next) =&amp;gt; { if (context.Request.Path == &amp;#34;/ws&amp;#34;) { if (context.WebSockets.IsWebSocketRequest) { WebSocket webSocket = await context.WebSockets.AcceptWebSocketAsync(); await Echo(context, webSocket); } else { context.Response.StatusCode = 400; } } else { await next(); } });   要使用类似[HttpGet(&amp;quot;/xxx&amp;quot;)]这种特性标签的路由方式，可以自己写一个简单的Attribute来实现。
1. 实现Attribute特性类 这个Attribute类很简单，只接收一个定义的Path，用来和开头提到的Request.Path对应。
1 2 3 4 5 6 7 8 9 10 11 12 13  /// &amp;lt;summary&amp;gt;  /// WebSockets执行函数特性标签  /// &amp;lt;/summary&amp;gt; [AttributeUsage(AttributeTargets.</description>
    </item>
    
    <item>
      <title>深入了解fmt包</title>
      <link>/golang/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3fmt%E5%8C%85/</link>
      <pubDate>Sat, 12 Jan 2019 20:39:10 +0800</pubDate>
      
      <guid>/golang/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3fmt%E5%8C%85/</guid>
      <description>英文原文：https://blog.gopheracademy.com/advent-2018/fmt/
 fmt包是我们最常使用的package，我们使用它打印输出一些内容，也可以当作字符串formatter工具。在这篇内容中我们再更进一步了解fmt的使用技巧。
Formatting Output Go fmt的方法支持多个“描述符”，一些常见的“描述符”例如：%s表示格式化输出为字符串，%d表示格式化输出为整数型，%f表示格式化输出为浮点类型。除了这些常见的，这里介绍一些其他的fmt包的“描述符”：
%v&amp;amp;%T %v将会格式化输出任意的变量的值，%T则会格式化输出任意变量的类型（type）
1 2  var e interface{} = 2.7182 fmt.Printf(&amp;#34;e = %v (%T)\n&amp;#34;, e, e)   输出：
1  e = 2.7182 (float64)   宽度 可以在格式化输出的时候，指定输出内容的宽度，例如：
1  fmt.Println(&amp;#34;[%10d]\n&amp;#34;, 353)   输出：
1  [ 353]   可以看到输出的内容在353前面多了7个空格(我真的数了)，加上“353”正好是10个字符，这就是“宽度”的意思，把变量格式化为指定的宽度输出。当然指定的宽度如果小于要输出的内容，那么就不会生效了。
这个宽度可以用在其他的“描述符”中，%s、%f、%T等等，对于%T这种使用宽度时，会给类型描述设置宽度，这么描述可能不清楚，可以看看代码：
1 2  s := &amp;#34;123&amp;#34; fmt.Printf(&amp;#34;[%10T]\n&amp;#34;, s) // 输出：[ string]   也可以在参数中指定宽度的数值，使用*来指代宽度数值参数，例如：
1  fmt.Printf(&amp;#34;%*d&amp;#34;, 10, 353)   输出：</description>
    </item>
    
    <item>
      <title>一个简单的逻辑英语音频小爬虫</title>
      <link>/golang/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%BB%E8%BE%91%E8%8B%B1%E8%AF%AD%E9%9F%B3%E9%A2%91%E5%B0%8F%E7%88%AC%E8%99%AB/</link>
      <pubDate>Wed, 05 Dec 2018 21:41:32 +0800</pubDate>
      
      <guid>/golang/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%BB%E8%BE%91%E8%8B%B1%E8%AF%AD%E9%9F%B3%E9%A2%91%E5%B0%8F%E7%88%AC%E8%99%AB/</guid>
      <description>最近在看逻辑英语的课程，感觉还挺不错的，不过看完视频好像啥也没记住😥，正好看见有逻辑英语的纸质书就买了一本没事可以翻翻，这本书随书赠送了一些配套的音频，但是都是一个一个的分开在微信公众号文章内的，想要下载下来听比较方便一些，所以研究了一下，花了十几分钟写了个小爬虫，趁着有空写篇博客记录一下。
1. 网页分析 首先我们打开音频的汇总页面，看一下这个页面的HTML结构。 可以看到每一个音频都指向一个公众号图文网页，只需要获取这些href的链接就可以进去音频的页面了。
接下来我们进入图文页面，看看怎么获取音频文件。 在音频页面找了一下，没有发现有音频文件的，也没有找到&amp;lt;audio&amp;gt;标签，但是发现有一个不认识的标签mpvoice，看起来像是微信自己弄的一个标签，看来从页面上不能直接获取音频文件了。
先不管HTML代码了，点击播放按钮看一下是怎么播放的。
没有发现什么有价值的东西，先放弃分析HTML了，看看Network中有什么有用的东西，点完之后果然有收获。 看这个接口大概就可以猜到是获取音频的，复制链接在新窗口打开，果真是音频文件。在打开几个音频图文，可以发现每个音频调用的都是相同的接口，唯一的区别就是查询参数mediaid的值不同，由此可以知道微信图文获取音频是调用该接口，带上音频的一个id就可以获取。
接下来就是找找mediaid在哪里了，打开HTML代码，很容易就发现了在&amp;lt;mpvoice&amp;gt;标签上有一个voice_encode_fileid属性的值就是mediaid的值。
分析完了页面的结构，接下来就很容易写代码了。
2. 代码编写 使用Go语言写简单的爬虫很快，先说几个关键点，然后贴完整的代码。
代码使用了github.com/PuerkitoBio/goquery这个库解析HTML结构的，如果你熟悉JQuery的使用，那么可以很容易的使用这个库解析HTML获取有用的数据。
1 2 3 4 5  // 创建音频汇总列表的DOM读取器 doc, docErr := goquery.NewDocumentFromReader(strings.NewReader(res)) if docErr!=nil { log.Fatalf(&amp;#34;%v&amp;#34;,docErr) }    首先使用NewDocumentFromReader函数将获取的页面HTML字符串，转换成goquery中的Document结构，Document中包含的Node可以由选择器语法进行解析。  1 2 3 4 5  // 读取列表中的每一个音频链接 doc.Find(&amp;#34;section a&amp;#34;).Each(func(i int,s *goquery.Selection){ mp3Url:=s.AttrOr(&amp;#34;href&amp;#34;,&amp;#34;&amp;#34;) log.Printf(&amp;#34;%v&amp;#34;,mp3Url) })    使用Find函数获取HTML中的指定Node，指定的方式是跟使用Jquery一样的，例如这里我们查找section标签下的a标签。 由于a标签是有很多个的，所以这里使用Each函数处理每一个节点。 然后在循环中，获取每一个a标签的href属性的值。获取节点属性的值有两个方法:  AttrOr(&amp;quot;&amp;quot;,&amp;quot;&amp;quot;)：第一个参数是属性的名字，第二个参数是没有找到指定的属性时，默认返回的值。 Attr(&amp;quot;&amp;quot;)：这个方法如果没有找到指定的属性，就会返回string和bool类型的零值，否则就返回指定属性的值和true。   完整的代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  package main import ( &amp;#34;os&amp;#34; &amp;#34;io&amp;#34; &amp;#34;log&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Angular知识点汇总(5)：HTTP服务通信</title>
      <link>/frontend/angular%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB5http%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Thu, 25 Oct 2018 21:04:40 +0800</pubDate>
      
      <guid>/frontend/angular%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB5http%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/</guid>
      <description>1. 响应式编程 在开始写HTTP通信之前，先简单的说一个必要的知识点：响应式编程，因为在Angular的HTTP通信中，返回的结果通常都是一个可观察对象，而响应式编程就是一个观察者模式(可观察对象)的实现。
1.1. 名词解释  可观察对象（Observable）：可观察对象基本上可以理解为观察者订阅者模式，可观察对象可以发送多种类型的值(字面量、消息、事件)，无论这些值是同步发送还是异步发送的，我们都无需在意，只需要订阅这个可观察对象，并且消费它的数据即可，消费完取消订阅，无需其他的操作。 响应式编程：响应式编程是一种面向数据流和变更传播的异步编程范式（Wikipedia）。RxJS（响应式扩展的 JavaScript 版）是一个使用可观察对象进行响应式编程的库，它让组合异步代码和基于回调的代码变得更简单 (RxJS Docs)。RxJS 提供了一种对 Observable 类型的实现。  1.2. 简单例子 下面的代码基于rxjs6版本，6之前的版本语法差异较大，请自行查阅文档。
1 2 3 4 5 6 7 8 9 10 11 12 13  import { from } from &amp;#39;rxjs&amp;#39;; import { filter } from &amp;#39;rxjs/operators&amp;#39;; viewObservable(obj: any) { const names: string[] = [&amp;#39;zhangsan&amp;#39;, &amp;#39;lisi&amp;#39;, &amp;#39;wangwu&amp;#39;, &amp;#39;zhaosi&amp;#39;]; from(names).pipe( filter(f =&amp;gt; f.indexOf(&amp;#39;san&amp;#39;) &amp;gt;= 0, )).subscribe( result =&amp;gt; console.log(result), error =&amp;gt; console.error(error), () =&amp;gt; console.</description>
    </item>
    
    <item>
      <title>Angular知识点汇总(4)：Form表单</title>
      <link>/frontend/angular%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB4form%E8%A1%A8%E5%8D%95/</link>
      <pubDate>Thu, 18 Oct 2018 23:03:59 +0800</pubDate>
      
      <guid>/frontend/angular%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB4form%E8%A1%A8%E5%8D%95/</guid>
      <description>1. Angular的两种表单API 1.1. 概述 　Angular中有两种表单API，分别是模板式表单和响应式表单。模板式表单是通过Angular提供的指令在模板中对表单进行操作的，由于受限于HTML的语法功能，模板式表单只适合一些简单的表单使用场景。而响应式表单是通过组件中自定义数据模型实现对表单的操控。所以更适合复杂表单功能。
　Angular表单都需要使用一个数据模型来接收存储表单的数据，而这个数据模型并不是我们自定义的类型，而是需要使用Angular提供的特定类型FormControl、FormGroup、FormArray等来组成。
　在模板式表单中上述的数据模型是在HTML中使用Angular指令，由Angular帮我们生成的；响应式表单相反，这些都需要我们在组件中自定义，所以会更加灵活一些。
　模板式表单存在于FormModule模块中，响应式表单存在于ReactiveFormModule模块中，在使用的时候一定要将对应的模块import到app.module.ts根模块中。 2. 响应式表单 2.1. 如何建响应式表单数据模型 创建响应式表首先需要创建表单需要用到的数据模型，然后将数据模型使用指令“映射”到模板上。
要使用响应式表单需要将ReactiveFormsModule模块导入到app.module.ts模块中：
1 2 3 4 5 6 7 8 9 10  import { ReactiveFormsModule } from &amp;#39;@angular/forms&amp;#39;; @NgModule({ ... imports: [ ... ReactiveFormsModule ], ... }) export class AppModule { }   定义表单的数据模型需要用到Angular提供的三个类型FormControl、FormGroup、FormArray。
2.1.1. FormControl FormControl是表单模型的最小单位，也就相当于数据模型对象中的一个属性，具体到表单中可以保存的是一个input元素的值和其他元数据。
1  title: FormControl = new FormControl(&amp;#39;默认标题&amp;#39;);    FormControl的构造函数可以传入一个参数，表示默认值，例如绑定在input元素上时，就是该元素的默认输入。  2.1.2. FormGroup FormGroup从语义上看就是代表整个表单，但是也可以保存表单的一部分，它里面可以包含多个FormControl，可以包含多个FormGroup。</description>
    </item>
    
    <item>
      <title>Angular知识点汇总(3)：数据绑定</title>
      <link>/frontend/angular%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB3%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Tue, 16 Oct 2018 22:36:15 +0800</pubDate>
      
      <guid>/frontend/angular%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB3%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</guid>
      <description>1. 事件绑定 1.1. 事件绑定的语法 事件绑定的语法：
1 2  &amp;lt;input (input)=&amp;#34;onInputEvent($event)&amp;#34;&amp;gt; &amp;lt;button (click)=&amp;#34;onClickEvent()&amp;#34;&amp;gt;    (eventName)这种小括号包含事件名称的语法就是angular的事件绑定语法，可以将该事件绑定到组件中一个方法，该事件触发时，绑定的方法就会被执行。 &amp;lt;input (input)=&amp;quot;onInputEvent($event)&amp;quot;&amp;gt;  (input)：事件绑定语法，绑定的是DOM的原生事件。 onInputEvent：组件中的一个方法名称，该事件触发的时候就会调用这个方法了。 $event：浏览器的事件对象，包含当前事件的数据。   1.2. 组件中绑定的方法 1 2 3 4 5 6 7 8  ... export class TestComponent implements OnInit { constructor() { } ngOnInit() {} onInputEvent(event){ console.log(`您正在输入的内容：${event.target.value}`) } }    当输入事件触发的时候就会调用组件中的onInputEvent函数，在这里我们将输入的内容打印出来。 可以看到方法中接收一个浏览器的事件对象，要获取输入的值需要有两次调用.target.value。  1.3. 模板局部变量 上面的事件参数($event)输入的是原生的浏览器事件对象，有时我们只需要它的value就可以，这时我们可以使用angular提供的模板局部变量，语法的格式是：&amp;lt;input #valName&amp;gt;。
在这里定义两个HTML标签，分别打印浏览器事件对象和模板局部变量：
1 2  &amp;lt;input (input)=&amp;#34;onInputEvent($event)&amp;#34;&amp;gt; &amp;lt;input #myInput (input)=&amp;#34;onInputEvent(myInput)&amp;#34; id=&amp;#34;myInput&amp;#34;&amp;gt;    可以看到浏览器事件对象的属性较多，如果有需要更多数据的话可以使用该变量。 而模板局部变量只是一个DOM的引用，相当于是document.</description>
    </item>
    
    <item>
      <title>Angular知识点汇总(2)：路由系统</title>
      <link>/frontend/angular%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB2%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 13 Oct 2018 19:21:36 +0800</pubDate>
      
      <guid>/frontend/angular%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB2%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F/</guid>
      <description>1. 简介 　路由系统是Angular应用中不可或缺的组成，组件之间的导航关系都需要使用路由来进行规范，接下来先看一下Angular中的几个不同的路由对象，以及其作用：
   路由对象 作用     Routes 路由数据配置对象，保存URL与组件之间的映射关系   RouterOutlet 一个做占位符作用的指令，表示路由组件的内容在此展示   Router 在应用运行时期可以操作路由的对象，例如跳转到其他的组件操作   RouterLink 在HTML标签中声明导航URL的指令   ActivatedRoute 保存着当前激活路由数据的对象，可以用它获取路由地址、路由参数等    2. 生成带路由的项目 下面我们使用例子讲解各个路由的使用，重新生成一个带路由模板的基架项目：
1  ng new my-project-route --routing # routing参数可以生成一个带路由模块的项目   使用带routing参数生成的项目会在src/app文件夹下面多出来一个文件app-routing.module.ts，应用中用到的路由都在这里进行配置。
也可以使用命令在已有项目中生成一个路由模块(同样生成名称为app-routing的路由模块)：
1  ng generate module app-routing --flat --module=app   生成的模块文件中有下面代码，需要自行增加导入代码(查看这里)：
1 2 3 4 5 6 7  import { NgModule } from &amp;#39;@angular/core&amp;#39;; import { RouterModule, Routes } from &amp;#39;@angular/router&amp;#39;; @NgModule({ exports: [ RouterModule ] }) export class AppRoutingModule {}   3.</description>
    </item>
    
    <item>
      <title>Angular知识点汇总(1)：起步和项目结构介绍</title>
      <link>/frontend/angular%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB1%E8%B5%B7%E6%AD%A5%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 10 Oct 2018 22:13:31 +0800</pubDate>
      
      <guid>/frontend/angular%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB1%E8%B5%B7%E6%AD%A5%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</guid>
      <description>1. 起步 1.1. 安装angular-cli 首次学习的同学可以进入到angular-cli wiki页面，学习关于angular-cli的知识。 使用npm安装angular-cli(也可以使用cnpm进行安装，避免网络问题造成失败)：
1  npm install -g @angular/cli   或者可以使用yarn安装，同样可以避免网络问题：
1  yarn add golbal @angular/cli   1.2. 生成项目 找一个合适的文件夹，在文件中打开命令行工具，执行生成命令，angular-cli会帮我们生成一个基础项目，避免从0开始搭建的麻烦：
1 2  ng new my-project cd my-project   这里可能会因为网络的问题造成ng new my-project命令执行失败，造成生成的基架项目无法运行，可以将ng命令调用的包管理命令改成其他的工具，例如cnpm或者yarn：
 首先打开Home_Dir/.angular-config.json文件 然后修改其中packageManager的内容为指定的工具名：  1 2 3 4 5 6  { &amp;#34;version&amp;#34;: 1, &amp;#34;cli&amp;#34;: { &amp;#34;packageManager&amp;#34;: &amp;#34;yarn&amp;#34; // &amp;#34;cnpm&amp;#34; } }    然后再执行ng new my-project就不会因为网络问题失败了。  1.</description>
    </item>
    
    <item>
      <title>以Ajax方式下载文件流</title>
      <link>/frontend/%E4%BB%A5ajax%E6%96%B9%E5%BC%8F%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%B5%81/</link>
      <pubDate>Fri, 28 Sep 2018 17:37:10 +0800</pubDate>
      
      <guid>/frontend/%E4%BB%A5ajax%E6%96%B9%E5%BC%8F%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%B5%81/</guid>
      <description>最近在修改一个遗留老项目的导出功能，其中有一个功能因为其导出功能没有加载动画，所以在下载耗时稍长的时候，完全不知道页面在干什么，在解决的时候感觉前端框架用的多了，这种原生的问题还是有些棘手的，在此记录一下。
 1. 原有项目的问题 1.1. 使用拼接Form节点的方式 　由于老项目是使用的ASP.NET MVC编写的，没有使用流行的前端框架，所以在代码中该文件下载功能是用JavaScript拼接了一个form节点的方式，调用DOM的submit()方法进行提交请求下载的：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function downloadFunc(action, params) { //创建iframe  var downloadHelper = $(&amp;#39;&amp;lt;iframe style=&amp;#34;display:none;&amp;#34; id=&amp;#34;downloadHelper&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt;&amp;#39;).appendTo(&amp;#39;body&amp;#39;)[0]; var doc = downloadHelper.contentWindow.document; if (doc) { doc.open(); doc.write(&amp;#39;&amp;#39;); doc.writeln(abp.utils.formatString(&amp;#34;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;form id=&amp;#39;downloadForm_export_file&amp;#39; name=&amp;#39;downloadForm&amp;#39; method=&amp;#39;post&amp;#39; action=&amp;#39;{0}&amp;#39;&amp;gt;&amp;#34;, action)); for (var key in params){ doc.writeln(abp.utils.formatString(&amp;#34;&amp;lt;input type=&amp;#39;hidden&amp;#39; name=&amp;#39;{0}&amp;#39; value=&amp;#39;{1}&amp;#39;&amp;gt;&amp;#34;, key, params[key])); doc.</description>
    </item>
    
    <item>
      <title>Hexo博客迁移到Hugo</title>
      <link>/blog/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0hugo/</link>
      <pubDate>Thu, 26 Jul 2018 10:03:53 +0800</pubDate>
      
      <guid>/blog/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0hugo/</guid>
      <description>最近将Hexo迁移到了Hugo，过程还是比较曲折的，在这里记录以下迁移的过程。
 1. Hugo 　首先还是说一下为什么迁移吧，之前一直在使用Hexo编写博客，Hexo的主题毫无疑问是非常多的，编辑主题也很简单，因为大家可能都会或多或少的掌握前端开发；对比下来hugo的主题挺少，而且要编写的话还要掌握go语言的模板引擎，说实话这个模板引擎确实挺变态的，幸亏现在基本都是前后端分离开发，要不然能被这个模板语法折磨死。
迁移的主要原因还是喜欢折腾吧，其次就是正在学习go语言，发现hugo的生成速度真的是快，当初用Hexo的时候，觉得Hexo已经很快了，感受一下hugo才知道这速度真是杠杠滴。
hugo还有一个好处就是它本身作为一个程序运行的，没有其他的依赖，很方便的发布到github上，换电脑写博客也很方便，博客原文拉取下来安装个hugo就好。而Hexo就比较麻烦了，依赖太多迁移比较麻烦的。
2. 迁移碰到的一些问题  时间类型：  hexo的时间是不带时区的24小时制时间：yyyy-MM-dd HH:mm:ss
 hugo的时间是带时区的时间格式：yyyy-MM-ddTHH:mm:ss+HH:mm
  tags和categories：  Hexo的markdown文件头部使用的是yaml格式的，虽然Hugo也是支持这种格式的，但是在提交travis-ci编译的时候报错了：error calling union: can&#39;t iterate over string，找了一下原因，是把tags和categories的值当作数组遍历了。   3. 解决方法 由于上述问题，迁移遇到了困难，一个一个手动改太麻烦了，于是用golang写了一个简单的替换代码，可以直接将hexo的博客文档转换成hugo能够编译的。
// hexo的头部
1 2 3 4 5 6 7  --- title: Hexo博客迁移到Hugo date: 2018-07-26 10:03:53 categories: Blog tags: Hugo description: Hexo博客迁移到Hugo ---   // hugo的头部
1 2 3 4 5 6 7 8  --- title: &amp;#34;Hexo博客迁移到Hugo&amp;#34; date: 2018-07-26T10:03:53+08:00 tags: [&amp;#34;Hugo&amp;#34;] categories: [&amp;#34;Blog&amp;#34;] description: Hexo博客迁移到Hugo draft: false ---   可以看到只需要将tag和categories的值转成数组形式，将date转换成带时区的格式就可以了。</description>
    </item>
    
    <item>
      <title>Spring Boot Annotations</title>
      <link>/java/spring-boot-annotations/</link>
      <pubDate>Thu, 14 Jun 2018 11:00:01 +0800</pubDate>
      
      <guid>/java/spring-boot-annotations/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&#34;http://www.baeldung.com/spring-boot-annotations&#34;&gt;http://www.baeldung.com/spring-boot-annotations&lt;/a&gt;
此篇为译文，由于英语水平有限，可能对原文的理解有误，欢迎指正，不甚感激！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-概览&#34;&gt;1. 概览&lt;/h1&gt;

&lt;p&gt;Spring Boot的自动配置功能使创建Spring配置变得非常容易。&lt;/p&gt;

&lt;p&gt;在这个入门教程，我们将要探讨Spring Boot相关的注解，其注解来自于两个包：&lt;code&gt;org.springframework.boot.autoconfigure&lt;/code&gt;和&lt;code&gt;org.springframework.boot.autoconfigure.condition&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Vue-ElementUI upload组件的上传文件控制</title>
      <link>/frontend/vue-elementui-upload%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Thu, 14 Jun 2018 10:06:13 +0800</pubDate>
      
      <guid>/frontend/vue-elementui-upload%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6/</guid>
      <description>&lt;h1 id=&#34;1-上传失败文件恢复&#34;&gt;1. 上传失败文件恢复&lt;/h1&gt;

&lt;p&gt;element的上传组件有很多需要自行控制的东西，此次遇到的问题是怎么在上传失败后，保持选择的文件的不变，可以再次尝试上传。&lt;/p&gt;

&lt;p&gt;首先我们有一个事件，是上传失败后的回调事件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;   * 文件上传失败后的事件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;   */&lt;/span&gt;
  uploadErrorFunc(err, file, fileList){
      console.log(file)
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Spring Web Annotations</title>
      <link>/java/spring-web-annotations/</link>
      <pubDate>Wed, 13 Jun 2018 10:09:46 +0800</pubDate>
      
      <guid>/java/spring-web-annotations/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&#34;http://www.baeldung.com/spring-mvc-annotations&#34;&gt;http://www.baeldung.com/spring-mvc-annotations&lt;/a&gt;
此篇为译文，由于英语水平有限，可能对原文的理解有误，欢迎指正，不甚感激！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-概览&#34;&gt;1. 概览&lt;/h1&gt;

&lt;p&gt;在本篇教程中，我们将要探讨Spring web开发有关的注解(Spring MVC注解)，这些注解存在于&lt;code&gt;org.springframework.web.bind.annotation&lt;/code&gt;包中。&lt;/p&gt;

&lt;h1 id=&#34;2-requestmapping&#34;&gt;2. &lt;code&gt;@RequestMapping&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;简而言之，&lt;code&gt;@RequestMapping&lt;/code&gt;标记&lt;code&gt;@Controller&lt;/code&gt;类中的请求处理器(request handler)方法。可用的配置有：
- &lt;code&gt;path&lt;/code&gt;：或者别名&lt;code&gt;name&lt;/code&gt;、&lt;code&gt;value&lt;/code&gt;都可以作为参数名，它指定了哪个URL映射到当前的方法。
- &lt;code&gt;method&lt;/code&gt;：协调处理HTTP请求的方法。
- &lt;code&gt;params&lt;/code&gt;：根据HTTP请求参数的存在、不存在或者值来过滤请求。
- &lt;code&gt;headers&lt;/code&gt;：根据HTTP请求的&lt;code&gt;headers&lt;/code&gt;的存在、不存在或者值来过滤请求。
- &lt;code&gt;consumes&lt;/code&gt;：限制哪些HTTP请求主体中的媒体类型可以被该方法使用。
- &lt;code&gt;produces&lt;/code&gt;：限制改方法可以响应哪些HTTP媒体类型。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring Core Annotations</title>
      <link>/java/spring-core-annotationss/</link>
      <pubDate>Tue, 12 Jun 2018 10:15:12 +0800</pubDate>
      
      <guid>/java/spring-core-annotationss/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&#34;http://www.baeldung.com/spring-core-annotations&#34;&gt;http://www.baeldung.com/spring-core-annotations&lt;/a&gt;
此篇为译文，由于英语水平有限，可能对原文的理解有误，欢迎指正，不甚感激！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-概览&#34;&gt;1. 概览&lt;/h1&gt;

&lt;p&gt;我们可以利用&lt;code&gt;org.springframework.beans.factory.annotation&lt;/code&gt;和&lt;code&gt;org.springframework.context.annotation&lt;/code&gt;这两个包提供的注解功能使用Spring的依赖注入。
我们经常称它为&amp;rdquo;Spring core annotations&amp;rdquo;，我将在本教程对此进行回顾。&lt;/p&gt;

&lt;h1 id=&#34;2-di有关的注解&#34;&gt;2. DI有关的注解&lt;/h1&gt;

&lt;h2 id=&#34;2-1-autowired&#34;&gt;2.1. &lt;code&gt;@Autowired&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;我们可以使用&lt;code&gt;@Autowired&lt;/code&gt;注解标记需要Spring去解析和注入的依赖项。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring-AOP极简入门</title>
      <link>/java/spring-aop%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8/</link>
      <pubDate>Wed, 30 May 2018 22:36:50 +0800</pubDate>
      
      <guid>/java/spring-aop%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h1 id=&#34;1-apo介绍&#34;&gt;1. APO介绍&lt;/h1&gt;

&lt;h2 id=&#34;1-1-简介&#34;&gt;1.1. 简介&lt;/h2&gt;

&lt;p&gt;按照惯例先来一份&lt;a href=&#34;https://zh.wikipedia.org/wiki/面向侧面的程序设计&#34;&gt;维基百科的解释&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点（crosscutting concern）。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>5分钟概览TypeScript</title>
      <link>/frontend/5%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8Btypescript/</link>
      <pubDate>Sun, 15 Apr 2018 20:03:07 +0800</pubDate>
      
      <guid>/frontend/5%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8Btypescript/</guid>
      <description>5分钟快速上手，请猛击这里看官网文档。
 1. 简介 　TypeScript不是一种新的语言，可以认为是给JavaScript添加语言特性的语言扩展(例如在JavaScript还未出现import和装饰器的时候，TypeScript已经有了)，官方的说法是JavaScript的超集，最终还是会编译成JavaScript代码在浏览器执行。
2. 语法特性 　TypeScript是支持OOP开发的，对于有OOP经验的人来说是非常友好的，写过c#、Java、golang语言的开发者，很容易上手。
学习的时候，建议通读文档，中文文档非常全面，更新的也特别及时，建议多做参考，文档地址：点此！
3. 基础语法 3.1. 声明语法:  类、接口声明：  1 2 3 4 5 6  class Name{ // 声明成员 } interface IName{ // 声明成员 }    变量声明:
  1 2  let num: number = 1; // 显示赋值 let str: string; // 默认初始值    函数声明：  1 2 3  function func(val: string):void{ // 该函数需要一个string类型的参数，无返回值。 }   3.</description>
    </item>
    
    <item>
      <title>Java compareTo字符串比较函数</title>
      <link>/java/java-compareto%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 10 Dec 2017 19:23:27 +0800</pubDate>
      
      <guid>/java/java-compareto%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0/</guid>
      <description>1. 调用方式： int compareTo(String) compareTo函数可以直接使用String类型的变量调用，参数是需要比较的另一个字符串，返回值是一个int类型。
2. 关于返回值的三种判断 s1.compareTo(s2)//s1是原字符串，s2是参数字符串 返回值计算方式：原减参
 返回0  两个字符串相同  返回正负整数：
 原字符串中的所有字符，按照顺序都包含在参数字符串中时，返回的是，原字符串字符数减去参数字符串字符数。  1 2 3 4 5  String s1 = &amp;#34;Java&amp;#34;; String s2 = &amp;#34;JavaScript&amp;#34;; System.Out.Println(s1.compareTo(s2)); //输出-6 //解读：因为s1是原字符串，并且其中的4个字符全部在参数字符串s2中可以找到， // 所以在使用compareTo函数的时候，就是源字符串的长度4减去参数字符串的长度10等于-6    原字符串中有1个或以上的字符并不在参数字符串中时，返回的是，两个字符串中不相同的第一个字符的ASCII码(十进制表示)相减的值。  1 2 3 4 5 6  String s1 = &amp;#34;Javac&amp;#34;; String s2 = &amp;#34;JavaScript&amp;#34;; System.Out.Println(s1.compareTo(s2)); //输出16 // 解读：字符串s1中的第五个字符“c”对应的是s2中的“S”， // 所以两个是不包含的关系，使用ASCII码的十进制表示相减。 // “c”的ASCII码为99，“S”的ASCII码为83，利用“原减参”的规则，99-83=16     使用人话说： 我找你想比较一下我们俩拥有的水果是不是一模一样的，我有4个苹果，你也有4个苹果，但是你还有3个梨，这时候，我只能表示我比你少3个数量的水果。 过了一会儿，我从家里拿来一个橘子，加在一起和你比较了，这时候，橘子是只有我有，而你没有，这时候我才不管你有梨我没梨了，我就非得用这个橘子和你的梨比较价格。</description>
    </item>
    
    <item>
      <title>GoWeb示例笔记</title>
      <link>/golang/goweb%E7%A4%BA%E4%BE%8B%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 28 Oct 2017 17:05:51 +0800</pubDate>
      
      <guid>/golang/goweb%E7%A4%BA%E4%BE%8B%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;学习&lt;a href=&#34;http://books.studygolang.com/gowebexamples&#34;&gt;GoWeb示例&lt;/a&gt;的笔记，做了总结和摘录，加入了一些没有提到的知识点。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go by Example笔记</title>
      <link>/golang/go-by-example%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 26 Oct 2017 20:59:43 +0800</pubDate>
      
      <guid>/golang/go-by-example%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;学习&lt;a href=&#34;http://books.studygolang.com/gobyexample/&#34;&gt;Go by Example&lt;/a&gt;的笔记，做了总结和摘录，加入了一些没有提到的知识点。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何阅读源码总结</title>
      <link>/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 19 Oct 2017 23:53:11 +0800</pubDate>
      
      <guid>/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;思维导图&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MQ技术架构</title>
      <link>/architect/mq%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Tue, 17 Oct 2017 21:10:08 +0800</pubDate>
      
      <guid>/architect/mq%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;1-什么时候使用mq&#34;&gt;1. 什么时候使用MQ&lt;/h1&gt;

&lt;h2 id=&#34;1-1-什么是mq&#34;&gt;1.1. 什么是MQ？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;消息队列(Message Queue)是一种跨进程的通信机制，用于上下游传递消息。&lt;/li&gt;
&lt;li&gt;使用MQ，消息发送上只需要依赖MQ，逻辑上和物理上都不需要依赖其他的服务，对业务进行了解耦，消息上下游互相不依赖，只需要知道MQ的存在即可。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;MQ的不足之处：&lt;/li&gt;
&lt;li&gt;多了一个MQ组件，使系统更加复杂。&lt;/li&gt;
&lt;li&gt;消息的传递延时会增加(队列处理)&lt;/li&gt;
&lt;li&gt;消息可靠性和重复性互为矛盾(消息丢失后难以保证下次是否会重复执行该消息)&lt;/li&gt;
&lt;li&gt;下游无法知道上游的执行结果(上下游完全解耦，没有互相调用)&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Go标准库笔记Ⅰ：IO</title>
      <link>/golang/go%E6%A0%87%E5%87%86%E5%BA%93%E7%AC%94%E8%AE%B0io/</link>
      <pubDate>Sat, 14 Oct 2017 16:56:24 +0800</pubDate>
      
      <guid>/golang/go%E6%A0%87%E5%87%86%E5%BA%93%E7%AC%94%E8%AE%B0io/</guid>
      <description>&lt;h2 id=&#34;io-基本的i-o接口&#34;&gt;&lt;code&gt;io&lt;/code&gt;：基本的I/O接口&lt;/h2&gt;

&lt;h3 id=&#34;reader-接口&#34;&gt;&lt;code&gt;Reader&lt;/code&gt;接口&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Golang&#34; data-lang=&#34;Golang&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Golang&#34; data-lang=&#34;Golang&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Reader &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{
    &lt;span style=&#34;color:#50fa7b&#34;&gt;Read&lt;/span&gt;(p []&lt;span style=&#34;color:#8be9fd&#34;&gt;byte&lt;/span&gt;)(n &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;,err &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Read&lt;/code&gt;方法将&lt;code&gt;len(p)&lt;/code&gt;个字节读取到p中，返回值是读取的字节数和任何遇到的错误，这个错误可能是读取中遇到的意外或者EOF(end-of-file)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当&lt;code&gt;Read&lt;/code&gt;方法返回错误时，不代表没有读取到任何数据。&lt;strong&gt;调用者应该处理返回的任何数据，之后才处理可能的错误&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;即使&lt;code&gt;Read&lt;/code&gt;函数返回的的字节数小于&lt;code&gt;p&lt;/code&gt;的长度，函数也会返回完整的p；如果读取的数据不到&lt;code&gt;p&lt;/code&gt;的最大长度，&lt;code&gt;Read&lt;/code&gt;方法会返回当前读取到的可用数据，不会继续等待读取。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为所有实现了&lt;code&gt;Read&lt;/code&gt;方法的类型都相当于实现了&lt;code&gt;io.Reader&lt;/code&gt;接口，也就是说，在所有需要&lt;code&gt;io.Reader&lt;/code&gt;的地方，可以传递实现了&lt;code&gt;Read()&lt;/code&gt;方法的类型的实例。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Golang文本编码处理</title>
      <link>/golang/golang%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 05 Sep 2017 22:43:02 +0800</pubDate>
      
      <guid>/golang/golang%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81%E5%A4%84%E7%90%86/</guid>
      <description>1. strings库常见例子 1.1. strings.Contains()包含 1 2 3 4 5 6 7 8 9  import( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main(){ str := &amp;#34;hello world&amp;#34; fmt.Println(strings.Contains(str,&amp;#34;hello&amp;#34;)) //输出 true  fmt.Println(strings.Contains(str,&amp;#34;?&amp;#34;)) //输出 false }   1.2. strings.Index()索引 1 2 3 4 5 6 7 8  import( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main(){ str := &amp;#34;hello world&amp;#34; fmt.Println(strings.Index(str,&amp;#34;w&amp;#34;)) //输出 6 }   1.3. strings.Split()切割 1 2 3 4 5 6 7 8  import( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main(){ str := &amp;#34;hello,world&amp;#34; fmt.</description>
    </item>
    
    <item>
      <title>Go语言标准库-fmt</title>
      <link>/golang/go%E6%A0%87%E5%87%86%E5%BA%93-fmt/</link>
      <pubDate>Wed, 23 Aug 2017 20:56:34 +0800</pubDate>
      
      <guid>/golang/go%E6%A0%87%E5%87%86%E5%BA%93-fmt/</guid>
      <description>1. fmt包  fmt包实现了类似c语言的printf和scanf函数，实现格式化I/O函数。  1.1. printf函数 1.1.1. 示例类型和变量 1 2 3 4 5 6 7  type Human struct{ Name string } func main(){ var people = Human{Name:&amp;#34;zhangsan&amp;#34;} }   1.1.2. 普通占位符    占位符 说明 举例 输出     %v 相应值的默认格式 Printf(&amp;quot;%v&amp;quot;,people) {zhangsan}   %+v 打印结构体时，会添加字段名显示 Printf(&amp;quot;%+v&amp;quot;,people) {Name:zhangsan}   %#v 相应值的Go语法表示 Printf(&amp;quot;%#v&amp;quot;,people) main.Human{Name:zhangsan}   %T 相应值*类型*的Go语法表示 Printf(&amp;quot;%T&amp;quot;,people) main.Human   %% 表示输出一个%(类似转义符) Printf(&amp;quot;%%&amp;quot;) %    1.</description>
    </item>
    
    <item>
      <title>Go语言基础知识</title>
      <link>/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Fri, 11 Aug 2017 21:53:08 +0800</pubDate>
      
      <guid>/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>1. 基础知识  每个go程序都是由package定义的。package必须在源文件的第一行。 每个可执行程序必须有且只有一个main包，main包里面必须有main函数。  1 2 3 4 5  package main // todo func main(){ //TODO }    import
 多个包可以一个一个import：   1 2 3  import &amp;#34;fmt&amp;#34; import &amp;#34;os&amp;#34; import &amp;#34;log&amp;#34;    也可以简化：  1 2 3 4 5 6 7 8 9  import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;log&amp;#34; ) //调用 func main(){ fmt.Println(&amp;#34;hello world&amp;#34;); }    导入的包没有调用里面的函数等，就会导致编译失败。 可以设置别名：  1 2 3 4 5 6  import env &amp;#34;fmt&amp;#34; //调用 func main(){ env.</description>
    </item>
    
    <item>
      <title>Go命令操作工具</title>
      <link>/golang/go%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 09 Aug 2017 21:09:03 +0800</pubDate>
      
      <guid>/golang/go%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E5%B7%A5%E5%85%B7/</guid>
      <description>1. 查看Go命令 可以在命令行中执行go命令来查看所有的go命令： 2. Go命令 2.1. go build 主要用来编译代码，在编译的过程中，可以同时编译代码中引用的其他包。
 对于普通包，执行go build后不会生成任何文件。(执行gi install可以在$GOPATH/pkg目录下生成对应的文件) 如果是main包，执行go build后，会在当前的目录下生成一个可执行文件。(使用go install或go build -o [path]/a.exe可以在$GOPATH/bin目录下生成相应的文件) go build默认会编译当前目录下的所有go文件；如果只想编译某一个文件，可以在go build之后加上文件名，例如：go build name.go。 使用go build -o namexx.exe可以指定编译输出的文件名；默认的名称有两种情况：如果当前不是main包，那么就是package名；如果是main包那么就是第一个源文件的文件名。 go build会忽略目录下以“_”或者“.”开头的文件。 如果需要针对不同的操作系统进行不同的处理，可以根据不同系统名称后缀来命名文件，例如有一个读取数组的程序，针对不同的操作系统的执行代码有差异的，那么就有这么几个源文件：array_linux.go、array_darwin.go、array_windows.go、array_freebsd.go，在不同的操作系统下编译会选择相应系统名结尾的文件，忽略其他文件。  2.1.1. 参数介绍  -o 指定输出的文件名，可以带路径输出：go build a/b/c/name.exe -n 把需要执行的编译命令打印出来，但是不执行，只输出。 -v 打印出正在编译的包名 -x 和-n相同，只是-x在打印的同时会执行编译  2.2. go clean 这个命令是用来删除掉当前包中编译生成的文件，只剩下源文件。
2.2.1. 参数介绍  -i 清除使用go install安装的文件(关联的安装包和可运行文件)。 -n 把需要执行清除命令打印出来，但是不执行。 -r 循环清除在import中引入的包。 -x 和-n一样，只不过在打印的同时会执行清除命令。  2.3. go fmt 这个命令可以格式化你源文件中的代码，消除源文件中的编码不规范。
2.3.1. 参数介绍  -l 列出需要格式化的文件。 -w 把格式化后的内容直接写入对应的源文件中。 -s 简化文件中的代码。 -d 打印格式化前后的内容对比，不写入文件，默认是false。 -e 打印所有的语法错误。如果没有这个参数，默认只会打印前10个错误。  2.</description>
    </item>
    
    <item>
      <title>GO环境安装部署</title>
      <link>/golang/go%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Tue, 08 Aug 2017 21:50:58 +0800</pubDate>
      
      <guid>/golang/go%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</guid>
      <description>&lt;h1 id=&#34;windows安装go&#34;&gt;Windows安装GO&lt;/h1&gt;

&lt;p&gt;官网下载&lt;a href=&#34;https://golang.org/dl/&#34;&gt;https://golang.org/dl/&lt;/a&gt;
  Golang中国下载&lt;a href=&#34;https://golangtc.com/download&#34;&gt;https://golangtc.com/download&lt;/a&gt;
直接安装即可。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础：Map接口</title>
      <link>/java/java%E5%9F%BA%E7%A1%80map%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Tue, 20 Jun 2017 22:13:42 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80map%E6%8E%A5%E5%8F%A3/</guid>
      <description>1. Map接口  Map接口概述:  Map中存储元素是成对存在的，每一个元素都包含键和值(key、value)。 Map集合不能批量添加，只能执行单个添加操作。 Map集合中的key是不能重复的，但是value可以重复，每个键只能对应一个值。 Map下的主要实现类：HashMap、LinkedHashMap   1.1. Map接口中的常用方法  public V put(K key, V value) ：存储键值对 public void putAll(Map&amp;lt;? extends K, ? extends V&amp;gt; m) :添加一个相同类型的Map(注意限定符约束) 查看源码可以知道，无论是put还是putAll最终调用的都是putVal这个方法(putAll也是循环调用的该方法)  1 2 3 4 5 6  //可以看到第一个参数是一个hash final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict){} //从这里可以看出来，HashMap在存储的时候会对key进行hash操作，在putVal方法中对hash进行判断，用来判重 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); }    public V get(Object key) ：根据key获取value public V getOrDefault(Object key, V defaultValue) ：根据key获取value，并且传递一个默认的value，当该key的时候，就返回这个传过来的默认的value，这是JDK8中新扩展的方法。  1 2 3 4 5 6 7 8 9 10  public V get(Object key) { Node&amp;lt;K,V&amp;gt; e; return (e = getNode(hash(key), key)) == null ?</description>
    </item>
    
    <item>
      <title>Java基础：Set接口</title>
      <link>/java/java%E5%9F%BA%E7%A1%80set%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Fri, 16 Jun 2017 15:39:46 +0000</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80set%E6%8E%A5%E5%8F%A3/</guid>
      <description>1. Set接口  Set接口的特点  Set接口是不能包含重复元素的集合。 Set集合取出元素的方式可以采用：迭代器、foreach。   2. 实现类HashSet的存储和迭代  HashSet (哈希表)无序集合,存储和取出的顺序不同,没有索引,不存储重复元素 内部使用的map存储的，添加操作在内部实现是当作map的key存储的，所以不会出现重复元素。   1 2 3 4 5 6 7 8 9 10 11 12 13 14  public static void main(String[] args){ Set&amp;lt;String&amp;gt; set=new HashSet&amp;lt;String&amp;gt;(); set.add(&amp;#34;a1&amp;#34;); set.add(&amp;#34;a2&amp;#34;); set.add(&amp;#34;a3&amp;#34;); set.add(&amp;#34;a3&amp;#34;); //相同数据会存储失败  Iterator&amp;lt;String&amp;gt; iterator=set.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); //输出：a1 a2 a3  } for (String str : set) { System.out.println(str); //输出：a1 a2 a3  } }   3.</description>
    </item>
    
    <item>
      <title>Java基础：List接口</title>
      <link>/java/java%E5%9F%BA%E7%A1%80list%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Wed, 14 Jun 2017 22:00:58 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80list%E6%8E%A5%E5%8F%A3/</guid>
      <description>&lt;h1 id=&#34;1-list接口&#34;&gt;1. List接口&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;List接口的特点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它是一个元素存取有序的集合&lt;/li&gt;
&lt;li&gt;它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素。&lt;/li&gt;
&lt;li&gt;集合中可以有重复的元素。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List接口子类有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt;集合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt;集合&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;2-list接口的方法&#34;&gt;2. List接口的方法&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boolean add(E e);&lt;/code&gt; :将指定的元素添加到集合的末尾，返回是否添加成功&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void add(int index, E element);&lt;/code&gt;  :将指定元素添加到指定的索引处&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;function&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(){&lt;/span&gt;
    List&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt; list &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;();&lt;/span&gt;
    list&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;a1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;);&lt;/span&gt;
    list&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;a2&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;);&lt;/span&gt;
    list&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;a3&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;);&lt;/span&gt;
    list&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;a4&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;);&lt;/span&gt;
    System&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;list&lt;span style=&#34;color:#ff79c6&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#6272a4&#34;&gt;//输出：[a1, a2, a3, a4]
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    list&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#ff79c6&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;aa&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;);&lt;/span&gt;
    System&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;list&lt;span style=&#34;color:#ff79c6&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#6272a4&#34;&gt;//输出：[a1, aa, a2, a3, a4]
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Java基础：泛型</title>
      <link>/java/java%E5%9F%BA%E7%A1%80%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Thu, 08 Jun 2017 22:37:01 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80%E6%B3%9B%E5%9E%8B/</guid>
      <description>&lt;h1 id=&#34;1-泛型概述&#34;&gt;1. 泛型概述&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。&lt;/li&gt;
&lt;li&gt;泛型的本质就是参数化类型，也就是说把数据类型作为一个参数传递。例如：&lt;code&gt;private class Itr implements Iterator&amp;lt;E&amp;gt;{...}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;2-java中的伪泛型&#34;&gt;2. Java中的伪泛型&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;泛型只在编译时存在，编译之后的class文件中并不存在泛型。

&lt;ul&gt;
&lt;li&gt;例如:ArrayList&lt;String&gt; al=new ArrayList&lt;String&gt;();&lt;/li&gt;
&lt;li&gt;编译后:ArrayList al = new ArrayList();&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;泛型只是在编译期进行的类型安全检查机制，避免程序可能发生的错误。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Java基础：Iterator迭代器</title>
      <link>/java/java%E5%9F%BA%E7%A1%80iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sat, 03 Jun 2017 19:43:42 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>&lt;h1 id=&#34;1-迭代器的概述&#34;&gt;1. 迭代器的概述&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;迭代器概述:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java中有很多种集合，这些集合在存储元素的时候，存储的方式都是不尽相同的，那么对应的我们在取出元素的时候也不相同，为每一种集合设计一个取出方式显然是不合理的，所以就出现了一种屏蔽集合间差异的读取元素的方式，就是迭代器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，然后继续判断，如果有就继续取。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每种集合的底层的数据结构不同,例如ArrayList是数组,LinkedList底层是链表,但是无论使用那种集合,我们都会有判断是否有元素
以及取出里面的元素的动作,那么Java为我们提供一个迭代器定义了统一的判断元素和取元素的方法 。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Java基础：集合</title>
      <link>/java/java%E5%9F%BA%E7%A1%80%E9%9B%86%E5%90%88/</link>
      <pubDate>Thu, 01 Jun 2017 20:28:49 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80%E9%9B%86%E5%90%88/</guid>
      <description>&lt;h1 id=&#34;1-集合概述&#34;&gt;1. 集合概述&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;集合，集合是java中提供的一种容器，可以用来存储多个数据

&lt;ul&gt;
&lt;li&gt;数组的长度是固定的。集合的长度是可变的&lt;/li&gt;
&lt;li&gt;集合中存储的元素必须是引用类型数据(基本类型可以使用包装类，Java内部自动帮我们做了拆装箱操作)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Java基础：数值类型操作</title>
      <link>/java/java%E5%9F%BA%E7%A1%80%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 30 May 2017 23:51:32 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;h1 id=&#34;1-math类的方法&#34;&gt;1. Math类的方法&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public static double sqrt(double a)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;返回参数的平方根&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;function&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(){&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd&#34;&gt;double&lt;/span&gt; d &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; Math&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;sqrt&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;7&lt;span style=&#34;color:#ff79c6&#34;&gt;);&lt;/span&gt;
   	System&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;d&lt;span style=&#34;color:#ff79c6&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#6272a4&#34;&gt;//输出：2.6457513110645907
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Java基础：System类</title>
      <link>/java/java%E5%9F%BA%E7%A1%80system%E7%B1%BB/</link>
      <pubDate>Sun, 28 May 2017 21:48:41 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80system%E7%B1%BB/</guid>
      <description>&lt;h1 id=&#34;1-system类方法currenttimemillis&#34;&gt;1. System类方法currentTimeMillis&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;System类方法&lt;code&gt;currentTimeMillis()&lt;/code&gt;:获取系统当前的毫秒值&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;*  获取系统当前毫秒值
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;*  static long currentTimeMillis()
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;*  对程序执行时间测试
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;*/&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;function&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(){&lt;/span&gt;
    &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; start &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; System&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;currentTimeMillis&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;();&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//当前时间x-1970年1月1日零时零分零秒
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; 0 &lt;span style=&#34;color:#ff79c6&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt; 10000&lt;span style=&#34;color:#ff79c6&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#ff79c6&#34;&gt;++){&lt;/span&gt;
      	System&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;i&lt;span style=&#34;color:#ff79c6&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; end &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; System&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;currentTimeMillis&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;();&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//当前时间y-1970年1月1日零时零分零秒
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    System&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;end &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt; start&lt;span style=&#34;color:#ff79c6&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//当前时间y-当前时间x 
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Java基础：JAVA基本类型和包装类</title>
      <link>/java/java%E5%9F%BA%E7%A1%80%E5%8C%85%E8%A3%85%E7%B1%BB/</link>
      <pubDate>Sat, 27 May 2017 19:45:09 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80%E5%8C%85%E8%A3%85%E7%B1%BB/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&#34;http://alexyyek.github.io/2014/12/29/wrapperClass/&#34;&gt;http://alexyyek.github.io/2014/12/29/wrapperClass/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-java的包装类&#34;&gt;1. JAVA的包装类&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)，有些地方也翻译为外覆类或数据类型类，如下表所示：&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Java基础：Data&amp;Calendar</title>
      <link>/java/java%E5%9F%BA%E7%A1%80data-calendar/</link>
      <pubDate>Thu, 25 May 2017 19:18:10 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80data-calendar/</guid>
      <description>&lt;h1 id=&#34;1-date类的构造方法&#34;&gt;1. Date类的构造方法&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Date类的构造方法

&lt;ul&gt;
&lt;li&gt;空参构造

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public Date()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;带参构造

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public Date(long times)&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;2-date类的get和set方法&#34;&gt;2. Date类的get和set方法&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Date类的get和set方法

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public long getTime()&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;将当前的日期对象，转为对应的毫秒值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void setTime(long times);&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;根据给定的毫秒值，生成对应的日期对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Java基础：正则表达式</title>
      <link>/java/java%E5%9F%BA%E7%A1%80%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 22 May 2017 20:10:45 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>&lt;h1 id=&#34;1-正则表达式的概念和作用&#34;&gt;1. 正则表达式的概念和作用&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;正则表达式的概述

&lt;ul&gt;
&lt;li&gt;正则表达式也是一个字符串，用来定义匹配规则，在Pattern类中有简单的规则定义。可以结合字符串类的方法使用。&lt;/li&gt;
&lt;li&gt;正则表达式是具有特殊含义的字符串。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;正则表达式的作用

&lt;ul&gt;
&lt;li&gt;比如注册账户,需要输入用户名和密码,一般会对其限制长度,这个限制长度的事情就是正则表达式做的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Java基础：String类</title>
      <link>/java/java%E5%9F%BA%E7%A1%80string%E7%B1%BB/</link>
      <pubDate>Sun, 21 May 2017 22:13:33 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80string%E7%B1%BB/</guid>
      <description>&lt;h1 id=&#34;1-string类的概念和不变性&#34;&gt;1. String类的概念和不变性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;String类的概念和不变性

&lt;ul&gt;
&lt;li&gt;String类

&lt;ul&gt;
&lt;li&gt;API中的String类的描述，发现String 类代表字符串&lt;/li&gt;
&lt;li&gt;Java 程序中的所有字符串字面值（如 &amp;ldquo;abc&amp;rdquo; ）都作为此类的实例实现。&lt;/li&gt;
&lt;li&gt;字符串是常量,在创建之后不能更改&lt;/li&gt;
&lt;li&gt;其实就是说一旦这个字符串确定了，那么就会在内存区域中就生成了这个字符串。字符串本身不能改变，但str变量中记录的地址值是可以改变的。&lt;/li&gt;
&lt;li&gt;源码分析,String类底层采用的是字符数组:&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Java基础：StringBuffer&amp;StringBuilder</title>
      <link>/java/java%E5%9F%BA%E7%A1%80stringbuffer-stringbuilder/</link>
      <pubDate>Sun, 21 May 2017 21:02:18 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80stringbuffer-stringbuilder/</guid>
      <description>&lt;h1 id=&#34;1-stringbuffer特点可变字符数组&#34;&gt;1. StringBuffer特点可变字符数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;StringBuffe&lt;/code&gt;r类概述

&lt;ul&gt;
&lt;li&gt;线程安全的可变字符序列&lt;/li&gt;
&lt;li&gt;底层采用字符数组实现,初始容量为16&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringBuffer&lt;/code&gt;和&lt;code&gt;String&lt;/code&gt;的区别

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt;是一个不可变的字符序列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringBuffer&lt;/code&gt;是一个可变的字符序列&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Java基础：Object类</title>
      <link>/java/java%E5%9F%BA%E7%A1%80object%E7%B1%BB/</link>
      <pubDate>Fri, 12 May 2017 21:56:17 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80object%E7%B1%BB/</guid>
      <description>&lt;h1 id=&#34;1-object类概述&#34;&gt;1. Object类概述&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Object类概述

&lt;ul&gt;
&lt;li&gt;类层次结构的根类&lt;/li&gt;
&lt;li&gt;所有类都直接或者间接的继承自该类&lt;/li&gt;
&lt;li&gt;Object中描述的所有方法子类都可以使用&lt;/li&gt;
&lt;li&gt;所有类在创建对象的时候，最终找的父类就是Object。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;2-equals方法比较内存地址&#34;&gt;2. equals方法比较内存地址&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Object类中的equals方法

&lt;ul&gt;
&lt;li&gt;用于比较两个对象是否相同，Object类中就是使用两个对象的内存地址在比较。&lt;/li&gt;
&lt;li&gt;Object类中的&lt;code&gt;equals&lt;/code&gt;方法内部使用的就是&lt;code&gt;==&lt;/code&gt;比较运算符。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Java基础：修饰符</title>
      <link>/java/java%E5%9F%BA%E7%A1%80%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Thu, 11 May 2017 13:04:09 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>&lt;h1 id=&#34;1-权限修饰符&#34;&gt;1. 权限修饰符&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;权限修饰符有哪些

&lt;ul&gt;
&lt;li&gt;在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;范围&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;public&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;protected&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;default&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;private&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;同一类中&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;✔&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;同一包中(子类与无关类)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;不同包的子类&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;不同包中的无关类&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>Java基础：final&amp;匿名类&amp;代码块</title>
      <link>/java/java%E5%9F%BA%E7%A1%80final%E5%8C%BF%E5%90%8D%E7%B1%BB%E4%BB%A3%E7%A0%81%E5%9D%97/</link>
      <pubDate>Sun, 23 Apr 2017 07:23:27 +0000</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80final%E5%8C%BF%E5%90%8D%E7%B1%BB%E4%BB%A3%E7%A0%81%E5%9D%97/</guid>
      <description># final关键字
 概述
 继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢？ 要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。 final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。    final修饰类  final 修饰类
 final修饰类不可以被继承，但是可以继承其他类。  1 2 3  class Obj {} final class Parent extends Obj{} //可以继承Obj类 class Sub extends Parent{} //不能继承Parent类    final修饰方法  final修饰方法
 final修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加final。  1 2 3 4 5 6 7 8 9  class Parent { // final修饰的方法，不可以被覆盖，但可以继承使用 public final void method1(){} public void method2(){} } class Sub extends Parent { //重写method2方法 public final void method2(){} }    final修饰局部变量  修饰基本数据类型变量</description>
    </item>
    
    <item>
      <title>使用Visual Studio远程调试</title>
      <link>/tool/%E4%BD%BF%E7%94%A8visual-studio%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</link>
      <pubDate>Wed, 12 Apr 2017 21:18:28 +0800</pubDate>
      
      <guid>/tool/%E4%BD%BF%E7%94%A8visual-studio%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本篇记录使用本地Visual Studio对远程服务器上部署的web站点进行断点调试。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-准备工作&#34;&gt;1. 准备工作&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;复制vs远程调试文件到服务器c盘，文件夹路径：&lt;code&gt;Common7/IDE/Remote Debugger/x64&lt;/code&gt; (整个文件夹复制进去)

&lt;ol&gt;
&lt;li&gt;运行其中的&lt;code&gt;msvsmon.exe&lt;/code&gt;可执行程序&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>RabbitMQ快速上手</title>
      <link>/message-queue/rabbitmq%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Tue, 11 Apr 2017 20:18:59 +0800</pubDate>
      
      <guid>/message-queue/rabbitmq%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;　　这是一篇简单的快速上手文章，不对RabbitMQ做过多的研究，只对安装使用的要点做一些提示，详细的使用心得，有时间记录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-安装&#34;&gt;1. 安装&lt;/h1&gt;

&lt;p&gt;　　演示一下windows版本的安装：由于RabbitMQ使用Erlang编写的，需要运行在Erlang运行时环境上，首先需要安装&lt;strong&gt;Erlang&lt;/strong&gt;语言，然后安装RabbitMQ的windows版本服务端。&lt;strong&gt;&lt;a href=&#34;http://www.erlang.org/download.html&#34;&gt;Erlang下载&lt;/a&gt;&lt;/strong&gt;  &lt;strong&gt;&lt;a href=&#34;http://www.rabbitmq.com/download.html&#34;&gt;RabbitMQ下载&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-1-以windows-service的方式启动运行&#34;&gt;1.1. 以windows service的方式启动运行&lt;/h2&gt;

&lt;p&gt;　　以windows服务的形式启动RabbitMQ,可以在后台自动运行；我们进入RabbitMQ的安装目录，进入安装目录种的&lt;strong&gt;sbin&lt;/strong&gt;目录下，以&lt;strong&gt;管理员权限&lt;/strong&gt;打开cmd命令行工具，分别执行下列三条命令：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础：this&amp;super关键字</title>
      <link>/java/java%E5%9F%BA%E7%A1%80thissuper%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Mon, 10 Apr 2017 19:23:27 +0800</pubDate>
      
      <guid>/java/java%E5%9F%BA%E7%A1%80thissuper%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>&lt;h1 id=&#34;1-为什么要有构造方法&#34;&gt;1. 为什么要有构造方法？&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;构造方法的作用:

&lt;ul&gt;
&lt;li&gt;在new的同时给成员变量赋值,给对象属性进行初始化。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;2-构造方法的定义和运行特点&#34;&gt;2. 构造方法的定义和运行特点&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;构造方法定义
构造方法的格式：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;修饰符 &lt;span style=&#34;color:#50fa7b&#34;&gt;构造方法名&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;(&lt;/span&gt;参数列表&lt;span style=&#34;color:#ff79c6&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>在树莓派3上部署qiandao.today签到程序</title>
      <link>/raspberry/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE3%E4%B8%8A%E9%83%A8%E7%BD%B2qiandao-today%E7%AD%BE%E5%88%B0%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Wed, 15 Mar 2017 20:41:35 +0800</pubDate>
      
      <guid>/raspberry/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE3%E4%B8%8A%E9%83%A8%E7%BD%B2qiandao-today%E7%AD%BE%E5%88%B0%E7%A8%8B%E5%BA%8F/</guid>
      <description>&lt;h1 id=&#34;1-项目介绍&#34;&gt;1. 项目介绍&lt;/h1&gt;

&lt;p&gt;　　&lt;a href=&#34;https://qiandao.today/&#34;&gt;qiandao.today&lt;/a&gt;是一个在github上开源的自动签到框架，使用python开发，作者是&lt;a href=&#34;http://binux.me/&#34;&gt;binux&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　github:&lt;a href=&#34;https://github.com/binux/qiandao&#34;&gt;https://github.com/binux/qiandao&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-部署在本地的树莓派上&#34;&gt;2. 部署在本地的树莓派上&lt;/h1&gt;

&lt;h2 id=&#34;2-1-准备&#34;&gt;2.1. 准备&lt;/h2&gt;

&lt;p&gt;　　首先我们准备一台安装好linux系统(raspbian、ubuntu等)的树莓派(我这里使用的是树莓派3)，连接接显示器并联网，连接键鼠。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>微信JSSDK的使用</title>
      <link>/csharp/%E5%BE%AE%E4%BF%A1jssdk%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 15 Mar 2017 20:33:03 +0800</pubDate>
      
      <guid>/csharp/%E5%BE%AE%E4%BF%A1jssdk%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;h1 id=&#34;1-概述和官方文档&#34;&gt;1. 概述和官方文档&lt;/h1&gt;

&lt;p&gt;　　使用微信JSSDK可以在网页中调用手机的拍照语音、定位等手机系统功能，还可以定制微信分享、扫一扫、卡券、支付等微信功能。
　　官方文档：&lt;a href=&#34;http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html&#34;&gt;http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html&lt;/a&gt;
　　&lt;/p&gt;

&lt;h1 id=&#34;2-调用步骤&#34;&gt;2. 调用步骤&lt;/h1&gt;

&lt;h2 id=&#34;2-1-绑定域名&#34;&gt;2.1. 绑定域名&lt;/h2&gt;

&lt;p&gt;　　首先进入&lt;a href=&#34;http://mp.weixin.qq.com/&#34;&gt;微信公众号后台&lt;/a&gt;，进入公众号设置=&amp;gt;功能设置=&amp;gt;JS接口安全域名设置：在这里可以设置三个调用的JSSDK的域名，然后将提示信息注意事项3中的&lt;a href=&#34;https://mp.weixin.qq.com/cgi-bin/mpverifytxt?lang=zh_CN&amp;amp;token=1492992380&#34;&gt;文件下载&lt;/a&gt;下来，放到网站的根目录下，点击保存，微信会自动测试是否设置成功。&lt;/p&gt;

&lt;h2 id=&#34;2-2-页面引入js文件&#34;&gt;2.2. 页面引入JS文件&lt;/h2&gt;

&lt;p&gt;　　在需要使用到JSSDK的页面引入微信提供的js文件，可以支持https协议，下载：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用CKEditor时碰到的一个坑</title>
      <link>/frontend/%E4%BD%BF%E7%94%A8ckeditor%E6%97%B6%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</link>
      <pubDate>Sun, 26 Feb 2017 21:54:03 +0800</pubDate>
      
      <guid>/frontend/%E4%BD%BF%E7%94%A8ckeditor%E6%97%B6%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</guid>
      <description>&lt;h1 id=&#34;1-问题&#34;&gt;1. 问题&lt;/h1&gt;

&lt;p&gt;　　CKEditor的配置文件有很多配置项，我们在使用的时候如果不指定需要那些工具条按钮，默认就会全部显示出来，在配置文件中可以只选择我们需要的一些按钮，比如纯文本编辑的时候，我们会把图片上传按钮去掉，或者不允许斜体加粗之类的操作。
   工具条具体的配置是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JavaScript&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JavaScript&#34; data-lang=&#34;JavaScript&#34;&gt;config.toolbarGroups &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; [
        { name&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;basicstyles&amp;#39;&lt;/span&gt;, groups&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; [&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;basicstyles&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;cleanup&amp;#39;&lt;/span&gt;] },
        { name&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;paragraph&amp;#39;&lt;/span&gt;, groups&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; [&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;list&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;indent&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;blocks&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;align&amp;#39;&lt;/span&gt;] },
        { name&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;styles&amp;#39;&lt;/span&gt; },
        { name&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;colors&amp;#39;&lt;/span&gt; }
    ];
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>使用CsvHelper导入导出csv文件</title>
      <link>/csharp/%E4%BD%BF%E7%94%A8csvhelper%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BAcsv%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sat, 25 Feb 2017 00:39:03 +0800</pubDate>
      
      <guid>/csharp/%E4%BD%BF%E7%94%A8csvhelper%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BAcsv%E6%96%87%E4%BB%B6/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;今天记录一下使用&lt;a href=&#34;https://github.com/JoshClose/CsvHelper&#34;&gt;CsvHelper&lt;/a&gt;导入导出CSV文件的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-csv介绍&#34;&gt;1. CSV介绍&lt;/h1&gt;

&lt;p&gt;　　csv文件是一种纯文本存储的文件格式，行和列分别用逗号和换行来代替，可以直接使用Excel打开。在代码中可以直接使用&lt;code&gt;TextWrite&lt;/code&gt; 操作，比较方便快速。&lt;/p&gt;

&lt;h1 id=&#34;2-csvhelper&#34;&gt;2. CsvHelper&lt;/h1&gt;

&lt;h2 id=&#34;2-1-项目介绍&#34;&gt;2.1. 项目介绍：&lt;/h2&gt;

&lt;p&gt;　　github主页：&lt;a href=&#34;https://github.com/JoshClose/CsvHelper&#34;&gt;https://github.com/JoshClose/CsvHelper&lt;/a&gt;
　　文档：&lt;a href=&#34;http://joshclose.github.io/CsvHelper/&#34;&gt;http://joshclose.github.io/CsvHelper/&lt;/a&gt;
　　wiki：&lt;a href=&#34;https://github.com/JoshClose/CsvHelper/wiki&#34;&gt;https://github.com/JoshClose/CsvHelper/wiki&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>bootstrap-fileinput组件在上传时传递额外参数</title>
      <link>/frontend/bootstrap-fileinput%E7%BB%84%E4%BB%B6%E5%9C%A8%E4%B8%8A%E4%BC%A0%E6%97%B6%E4%BC%A0%E9%80%92%E9%A2%9D%E5%A4%96%E5%8F%82%E6%95%B0/</link>
      <pubDate>Wed, 23 Nov 2016 20:54:46 +0800</pubDate>
      
      <guid>/frontend/bootstrap-fileinput%E7%BB%84%E4%BB%B6%E5%9C%A8%E4%B8%8A%E4%BC%A0%E6%97%B6%E4%BC%A0%E9%80%92%E9%A2%9D%E5%A4%96%E5%8F%82%E6%95%B0/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;该问题的使用场景是：在微信平台素材上传的页面使用，在上传时需要发送一个参数，让后台判断是临时素材还是永久素材。 但是该组件在一开始就已经初始化(问题所在)了要发送的参数，也就是说没有办法后期追加额外的参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　由于英文水平问题，阅读官方文档时没有找到该问题的解决方法，于是去github提了一个&lt;a href=&#34;https://github.com/kartik-v/bootstrap-fileinput/issues/795&#34;&gt;issue&lt;/a&gt; ，得到的答案是仔细阅读文档，里面有一个回调函数可以解决问题😍&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>对ASP.NET程序员非常有用的85个工具</title>
      <link>/tool/%E5%AF%B9asp-net%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E7%9A%8485%E4%B8%AA%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sun, 09 Oct 2016 23:01:48 +0800</pubDate>
      
      <guid>/tool/%E5%AF%B9asp-net%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E7%9A%8485%E4%B8%AA%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;h1 id=&#34;1-介绍&#34;&gt;1. 介绍&lt;/h1&gt;

&lt;p&gt;　　这篇文章列出了针对ASP.NET开发人员的有用工具。&lt;/p&gt;

&lt;h1 id=&#34;2-工具&#34;&gt;2. 工具&lt;/h1&gt;

&lt;h2 id=&#34;2-1-visual-studio&#34;&gt;2.1. Visual Studio&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://visualstudiogallery.msdn.microsoft.com/34ebc6a2-2777-421d-8914-e29c1dfa7f5d&#34;&gt;Visual Studio Productivity Power tool&lt;/a&gt;：Visual Studio专业版（及以上）的扩展，具有丰富的功能，如快速查找，导航解决方案，可搜索的附加参考对话框等&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jetbrains.com/resharper/&#34;&gt;ReSharper&lt;/a&gt;：提高.NET开发人员生产力的工具，提高代码质量，通过提供快速修复消除错误，等等&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mztools.com/v8/features.aspx#FindCodeFaster&#34;&gt;MZ-Tools&lt;/a&gt;：它可以在方法、文件、项目、解决方案或项目组、选定的文本，文件组合或项目组合中找到字符串。结果示于下面的结果窗口中，比由Microsoft IDE提供的要更方便。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://visualstudiogallery.msdn.microsoft.com/ee6e6d8c-c837-41fb-886a-6b50ae2d06a2&#34;&gt;Web Essentials&lt;/a&gt;：提高生产力和帮助高效编写CSS，JavaScript，HTML等&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>行走在白昼的夜里</title>
      <link>/%E6%96%87%E9%9B%86/%E8%A1%8C%E8%B5%B0%E5%9C%A8%E7%99%BD%E8%89%B2%E7%9A%84%E5%A4%9C%E9%87%8C/</link>
      <pubDate>Tue, 19 Jul 2016 11:11:36 +0800</pubDate>
      
      <guid>/%E6%96%87%E9%9B%86/%E8%A1%8C%E8%B5%B0%E5%9C%A8%E7%99%BD%E8%89%B2%E7%9A%84%E5%A4%9C%E9%87%8C/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;　　“我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　能代替太阳的，只有爱！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Hexo标签分类写错的处理</title>
      <link>/blog/hexo%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%E5%86%99%E9%94%99%E7%9A%84%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 18 Jul 2016 01:17:13 +0800</pubDate>
      
      <guid>/blog/hexo%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%E5%86%99%E9%94%99%E7%9A%84%E5%A4%84%E7%90%86/</guid>
      <description>&lt;p&gt;　　有时候我们会不小心写错了Hexo的标签，部署之后需要改正的话发现改完之后，之前的那个错误的标签或者分类的名字依然存在，这时我们需要删除本地的部署文件以及生成文件的json数据。&lt;/p&gt;

&lt;p&gt;　　打开Hexo博客，删除根目录下的&lt;strong&gt;db.json&lt;/strong&gt;文件和&lt;strong&gt;.deploy_git&lt;/strong&gt;文件夹。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>值类型和引用类型</title>
      <link>/csharp/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 17 Jul 2016 19:00:41 +0800</pubDate>
      
      <guid>/csharp/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>使用Fiddler抓包分析API</title>
      <link>/csharp/%E4%BD%BF%E7%94%A8fiddler4%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90api/</link>
      <pubDate>Sun, 17 Jul 2016 13:22:44 +0800</pubDate>
      
      <guid>/csharp/%E4%BD%BF%E7%94%A8fiddler4%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90api/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Fiddler是一个http协议调试代理工具，它能够记录并且检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指cookie,html,js,css等文件，这些都可以让你胡乱修改的意思）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式。Fiddler 是用C#写出来的,它包含一个简单却功能强大的基于JScript .NET 事件脚本子系统，它的灵活性非常棒，可以支持众多的http调试任务，并且能够使用.net框架语言进行扩展。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　摘录一下百科的解释，简单点说Fiddler是个抓包工具，测试人员可能用的比较多，在UWP开发中使用的，就是为了开发第三方的软件而进行分析API接口，至于为啥要开发第三方的UWP，这得把巨硬抓起来打一顿就知道了。
　　&lt;/p&gt;

&lt;h1 id=&#34;准备&#34;&gt;准备&lt;/h1&gt;

&lt;p&gt;　　需要的工具：Android手机，电脑，WiFi。
　　首先我们去官网(&lt;a href=&#34;https://www.telerik.com/download/fiddler&#34;&gt;www.telerik.com&lt;/a&gt;)下载并安装Fiddler软件。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>8、使用SSH方式部署博客</title>
      <link>/blog/8%E4%BD%BF%E7%94%A8ssh%E6%96%B9%E5%BC%8F%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sat, 14 May 2016 01:35:24 +0800</pubDate>
      
      <guid>/blog/8%E4%BD%BF%E7%94%A8ssh%E6%96%B9%E5%BC%8F%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</guid>
      <description>&lt;p&gt;　　每次写完博客提交都要输入账号密码，尤其是同时部署到了俩网站，输两个网站的账号密码，简直噩梦一般，这篇就是为了解除这个噩梦。&lt;/p&gt;

&lt;h1 id=&#34;1-什么是ssh&#34;&gt;1. 什么是SSH&lt;/h1&gt;

&lt;p&gt;　　简单说就是一种更加安全的网络传输协议。摘录一段维基百科的解释：
&amp;gt; Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。
传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。
而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。
SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。&lt;/p&gt;

&lt;h1 id=&#34;2-创建ssh&#34;&gt;2. 创建SSH&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;检查电脑上是否创建了SSH key
　　右键打开Git Bash，输入下面的命令，检查“.ssh”文件夹中是否已经创建了id_rsa id_rsa.pub known_hosts文件。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>7、解析博客域名</title>
      <link>/blog/7%E8%A7%A3%E6%9E%90%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D/</link>
      <pubDate>Sat, 14 May 2016 00:57:47 +0800</pubDate>
      
      <guid>/blog/7%E8%A7%A3%E6%9E%90%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D/</guid>
      <description>&lt;p&gt;　　这一篇我们介绍一下怎么解析域名，执行我们的博客，由于我的域名是在万网购买的，所以解析式在万网做的，下面的示例会已万网解析为例，好像万网也提供了解析服务，如果选择其他的解析服务，操作的大致方式都是一样的。&lt;/p&gt;

&lt;h1 id=&#34;1-给github绑定域名&#34;&gt;1. 给github绑定域名&lt;/h1&gt;

&lt;p&gt;　　首先我们需要给github绑定一个域名，也就是指定一个CNAME文件，这是将一个域名解析指向另一个域名的方式，如果想了解域名解析的相关知识点，网上有很多相关资料。😝
　　1. 进入到根目录下面的&lt;code&gt;source&lt;/code&gt;文件夹内，新建一个文本文件，名称为&lt;code&gt;CNAME&lt;/code&gt;。(注意没有后缀名)
　　2. 使用编辑器打开该文件，在里面写入你的域名，比如&lt;code&gt;www.hais2.com&lt;/code&gt;，那么你的博客就使用www.hais2.com访问，或者&lt;code&gt;hais2.com&lt;/code&gt;，那么你的博客就使用hais2.com访问。
　　3. 执行&lt;code&gt;hexo d -g&lt;/code&gt;命令部署发布。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UWP学习笔记:使用Grid和StackPanel布局</title>
      <link>/csharp/uwp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8grid%E5%92%8Cstackpanel%E5%B8%83%E5%B1%80/</link>
      <pubDate>Sun, 08 May 2016 21:40:48 +0800</pubDate>
      
      <guid>/csharp/uwp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8grid%E5%92%8Cstackpanel%E5%B8%83%E5%B1%80/</guid>
      <description>&lt;p&gt;　　第一篇关于UWP的笔记，学了几天的XAML布局，赶紧总结一下，免得健忘症发作。&lt;/p&gt;

&lt;h1 id=&#34;1-grid-https-msdn-microsoft-com-zh-cn-library-windows-apps-windows-ui-xaml-controls-grid-aspx&#34;&gt;1. &lt;a href=&#34;https://msdn.microsoft.com/zh-cn/library/windows/apps/windows.ui.xaml.controls.grid.aspx&#34;&gt;Grid&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;　　Grid顾名思义就是对页面进行网格布局的标签，可以将页面分成行(Row)和列(Column)交错的网格形式。&lt;/p&gt;

&lt;h2 id=&#34;1-1-设置行&#34;&gt;1.1. 设置行&lt;/h2&gt;

&lt;p&gt;　　&lt;code&gt;&amp;lt;Grid.RowDefintions&amp;gt;&amp;lt;/Grid.RowDefintions&amp;gt;&lt;/code&gt;标签可以设置行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;Grid.RowDefintions&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;RowDefinition&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Height=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Auto&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;RowDefinition&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Height=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;RowDefinition&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Height=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;2*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;RowDefinition&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Height=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
    ...
&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;/Grid.RowDefintions&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Guid.ToString()的格式化重载</title>
      <link>/csharp/guid-tostring-%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Wed, 20 Apr 2016 22:35:06 +0800</pubDate>
      
      <guid>/csharp/guid-tostring-%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%87%8D%E8%BD%BD/</guid>
      <description>&lt;p&gt;以下内容参考&lt;a href=&#34;https://msdn.microsoft.com/zh-cn/library/97af8hh4.aspx&#34;&gt;msdn&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;1-格式化guid的值&#34;&gt;1. 格式化Guid的值&lt;/h1&gt;

&lt;p&gt;　　&lt;code&gt;Guid.ToString();&lt;/code&gt;这个方法有一个重载，接收一个string类型的参数，这个参数有固定值：“N”、“D”、“B”、“P”或“X”。
　　分别表示：
　　&lt;code&gt;N&lt;/code&gt;:返回32位数字，比如：00000000000000000000000000000000
　　&lt;code&gt;D&lt;/code&gt;:返回由连字符分隔的32位数字，比如：00000000-0000-0000-0000-000000000000
　　&lt;code&gt;B&lt;/code&gt;:返回在大括号中、由连字符分隔的32位数字，比如：{00000000-0000-0000-0000-000000000000}
　　&lt;code&gt;P&lt;/code&gt;:返回在圆括号中、由连字符分隔的32位数字，比如：(00000000-0000-0000-0000-000000000000)
　　&lt;code&gt;X&lt;/code&gt;:返回括在大括号中的4个十六进制，其中第四个值是括在大括号中的8个十六进制值的子集，比如：{0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}}&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>EF code first简单示例</title>
      <link>/csharp/ef-code-first%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Wed, 13 Apr 2016 20:35:53 +0800</pubDate>
      
      <guid>/csharp/ef-code-first%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/</guid>
      <description>&lt;p&gt;　　一个简单的MVC5+EF6小demo，演示mvc和ef的简单编写流程。&lt;/p&gt;

&lt;h1 id=&#34;1-创建项目&#34;&gt;1. 创建项目&lt;/h1&gt;

&lt;p&gt;　　1、选择.Net Farmework版本为4.5以上的，这里我选择4.5.2
　　2、选择模板，选择&lt;strong&gt;Empty&lt;/strong&gt;，勾选MVC引用：&lt;img src=&#34;http://ww1.sinaimg.cn/mw690/c55a7aeegw1f2v56p11fvj20m80h8tc1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git常用命令总结</title>
      <link>/tool/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 28 Mar 2016 21:16:58 +0800</pubDate>
      
      <guid>/tool/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;　　本文持续更新&amp;hellip;
　　虽然很早就记录了很多的git命令在OneNote里面，但是作为手残党+健忘的我来说，敲命令行简直..那个啥。所以在开头推荐大家一款能够&lt;a href=&#34;https://github.com/gitextensions/gitextensions/releases/tag/v2.48.05&#34;&gt;鼠标点点点的git工具&lt;/a&gt;，哪里不会点哪里，妈妈再也不用担心我记不住git命令啦！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;  初始化git管理仓库&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;git add xxx.txt&lt;/code&gt;  将文件添加到暂存区中，可以单独添加文件，也可以使用“ git add . ”添加所有的未添加文件(“.”代表所有)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;git commit -m &amp;quot;提交说明&amp;quot;&lt;/code&gt;   提交暂存区中添加的文件到本地git库中。  题外话(注意，一定要写提交说明，而且要细粒度的提交，让工作更加细致)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;git status&lt;/code&gt;  查看当前仓库的状态，可以看详细的提示信息。Git status只能看到当前的仓库状态，当文件修改时，只能提示当前的文件修改了但是具体做了什么修改他是不知道的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt;    可以看到具体修改了什么内容&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>c#中yield的用法</title>
      <link>/csharp/c-%E4%B8%ADyield%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sat, 26 Mar 2016 17:01:24 +0800</pubDate>
      
      <guid>/csharp/c-%E4%B8%ADyield%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>&lt;p&gt;　　记录一下c#中的一个关键字&lt;code&gt;yield&lt;/code&gt;的用法，之前基本没怎么用过这个算是语法糖的关键字，最近做了一个小的机构账号管理项目，读取DataReader对象数据时，每一次都得Add到集合中，记得以前见过有人用过这个方法，写起来很方便，所以学习了一下，记录下来以备查看。&lt;/p&gt;

&lt;h1 id=&#34;1-之前查找数据库数据的部分代码&#34;&gt;1. 之前查找数据库数据的部分代码&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;public&lt;/span&gt; List&amp;lt;Organization&amp;gt; OrgModel=&lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; List&amp;lt;Organization&amp;gt;();
&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; sqlText=&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;select * from Organization&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#8be9fd&#34;&gt;var&lt;/span&gt; dataTable = SqlHelper.ExecuteReader(sqlText);
            &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (dataTable.HasRows)
            {
                &lt;span style=&#34;color:#ff79c6&#34;&gt;while&lt;/span&gt; (dataTable.Read())
                {
                    Organization org = &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; Organization();
                    org.org_code = dataTable&lt;span style=&#34;color:#50fa7b&#34;&gt;[&amp;#34;org_code&amp;#34;]&lt;/span&gt;.ToString();
                    org.org_name = dataTable&lt;span style=&#34;color:#50fa7b&#34;&gt;[&amp;#34;org_name&amp;#34;]&lt;/span&gt;.ToString();
                    org.org_acount = dataTable&lt;span style=&#34;color:#50fa7b&#34;&gt;[&amp;#34;org_acount&amp;#34;]&lt;/span&gt;.ToString();
                    org.org_password = dataTable&lt;span style=&#34;color:#50fa7b&#34;&gt;[&amp;#34;org_password&amp;#34;]&lt;/span&gt;.ToString();
                    OrgModel.Add(org);
                }
            }
            &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; orgModel;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>什么才算是真正的编程能力？</title>
      <link>/%E6%96%87%E9%9B%86/%E4%BB%80%E4%B9%88%E6%89%8D%E7%AE%97%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/</link>
      <pubDate>Fri, 25 Mar 2016 22:04:19 +0800</pubDate>
      
      <guid>/%E6%96%87%E9%9B%86/%E4%BB%80%E4%B9%88%E6%89%8D%E7%AE%97%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/</guid>
      <description>&lt;p&gt;转载自&lt;a href=&#34;http://www.imooc.com/article/1097&#34;&gt;慕课网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;知乎上看到一题主的发问：
还在读书，也在实验室帮忙做了些东西，自己也搭过几个网站。在周围人看来似乎好像我很厉害，做了那么多东西，但是我发现这些东西虽然是我做的，但是实际上我手把手自己写的代码却并没有多少，很多都是用开源的东西，我写的代码无非是把别人的东西整合下，类似于胶水一样的工作。&lt;/p&gt;

&lt;p&gt;我之前所认为的编程是全手动一行一行敲代码，但是现在我发现哪怕是工程上也有很多人是复制黏贴来解决问题的，并且提倡不要重复造轮子。&lt;/p&gt;

&lt;p&gt;但是靠谷歌和复制别人的轮子，虽然我做出了很多东西，可是我并不觉得自己能力上有提升，倒是利用搜索引擎的能力的确提升了不少。而学校里另外一波搞ACM的人，他们每天刷题练算法，或许倒是的确提升了点编程能力，但是对工程几乎一窍不通。&lt;/p&gt;

&lt;p&gt;所以我现在就很困惑，所谓的编程能力到底是什么，我该如何提升自己的编程能力？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>值得收藏的10个jQuery小技巧</title>
      <link>/frontend/%E5%80%BC%E5%BE%97%E6%94%B6%E8%97%8F%E7%9A%8410%E4%B8%AAjquery%E5%B0%8F%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Fri, 25 Mar 2016 21:25:54 +0800</pubDate>
      
      <guid>/frontend/%E5%80%BC%E5%BE%97%E6%94%B6%E8%97%8F%E7%9A%8410%E4%B8%AAjquery%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid>
      <description>&lt;p&gt;转载自&lt;a href=&#34;http://www.imooc.com/article/1686&#34;&gt;慕课网&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-返回顶部按钮&#34;&gt;1.返回顶部按钮&lt;/h1&gt;

&lt;p&gt;你可以利用 animate 和 scrollTop 来实现返回顶部的动画，而不需要使用其他插件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// Back to top
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;$(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;a.top&amp;#39;&lt;/span&gt;).click(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
  $(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.body).animate({scrollTop&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;}, &lt;span style=&#34;color:#bd93f9&#34;&gt;800&lt;/span&gt;);
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;;
});
&lt;span style=&#34;color:#6272a4&#34;&gt;&amp;lt;!--&lt;/span&gt; Create an anchor tag &lt;span style=&#34;color:#ff79c6&#34;&gt;--&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;a &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;top&amp;#34;&lt;/span&gt; href&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;#&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;Back to top&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;改变 scrollTop 的值可以调整返回距离顶部的距离，而 animate 的第二个参数是执行返回动作需要的时间(单位：毫秒)。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在ashx页中使用Session</title>
      <link>/csharp/%E5%9C%A8ashx%E9%A1%B5%E4%B8%AD%E4%BD%BF%E7%94%A8session/</link>
      <pubDate>Sun, 20 Mar 2016 23:30:19 +0800</pubDate>
      
      <guid>/csharp/%E5%9C%A8ashx%E9%A1%B5%E4%B8%AD%E4%BD%BF%E7%94%A8session/</guid>
      <description>&lt;p&gt;　　&lt;/p&gt;

&lt;h1 id=&#34;1-正文&#34;&gt;1. 正文&lt;/h1&gt;

&lt;p&gt;　　在ashx中使用Session不能直接&lt;code&gt;context.Session[&amp;quot;sessionName&amp;quot;]=value;&lt;/code&gt; ,需要引入一个命名空间和继承一个接口。
　　命名空间：&lt;code&gt;using System.Web.SessionState;&lt;/code&gt;  作用：“IRequiresSessionState”接口的命名空间
　　接口：&lt;code&gt;IRequiresSessionState&lt;/code&gt;    作用:指定目标 HTTP 处理程序需要对会话状态值具有读写访问权&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>6、将博客部署到coding并绑定域名</title>
      <link>/blog/6%E5%B0%86%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0coding%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</link>
      <pubDate>Tue, 08 Mar 2016 21:52:33 +0800</pubDate>
      
      <guid>/blog/6%E5%B0%86%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0coding%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</guid>
      <description>&lt;p&gt;　　由于墙的原因，github访问速度很慢，而且github屏蔽了百度蜘蛛，所以将博客部署到github对国内的访客来说，并不是最好的选择，这一篇我们介绍一下，怎么将博客同时部署到github和coding上，然后绑定域名，并且分别指向国外和国内线路。&lt;/p&gt;

&lt;h1 id=&#34;1-将博客同时部署到coding上&#34;&gt;1. 将博客同时部署到coding上&lt;/h1&gt;

&lt;p&gt;　　之前是gitcafe+github的部署方式，奈何gitcafe被coding给收了，感叹世事变幻无常啊。还好coding也提供了pages服务，我们可以将博客部署到coding上。
　　&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>5、Hexo博客的写作</title>
      <link>/blog/5hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%86%99%E4%BD%9C/</link>
      <pubDate>Mon, 07 Mar 2016 21:12:55 +0800</pubDate>
      
      <guid>/blog/5hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%86%99%E4%BD%9C/</guid>
      <description>&lt;p&gt;　　这一篇介绍一下Hexo中怎么写博客的，无论怎么折腾，认认真真的写博客才是最主要的。
　　&lt;/p&gt;

&lt;h1 id=&#34;1-创建文章&#34;&gt;1. 创建文章&lt;/h1&gt;

&lt;p&gt;　　Hexo创建一篇博文很简单，只需要在博客所在目录下打开“Git Bash Here”命令行窗口，输入：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;hexo new &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;你文章的名字&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　然后回车即可创建一篇文章。注意，在博客名称中没有特殊字符时可以不写双引号，但是建议大家每次都写上比较好。
　　创建的博文默认在&lt;code&gt;\source\_posts\&lt;/code&gt;目录下面，进入该文件夹，找到并打开即可。
　　打开之后可以看到，自动生成了一些信息：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>4、Hexo博客主题的修改</title>
      <link>/blog/4hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Sun, 06 Mar 2016 22:54:10 +0800</pubDate>
      
      <guid>/blog/4hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9/</guid>
      <description>&lt;p&gt;　　在这一篇中介绍一下Hexo主题的一些修改方法，在这里是基于默认主题介绍的，但是了解一下，对使用其他主题也有些帮助。&lt;/p&gt;

&lt;h1 id=&#34;1-主题文件说明&#34;&gt;1. 主题文件说明&lt;/h1&gt;

&lt;p&gt;　　依次打开博客文件夹根目录下的&lt;code&gt;themes\landscape\&lt;/code&gt;，可以看见主题包里面一些文件夹和文件，我们先认识一下这些文件分别是什么：
&lt;img src=&#34;http://ww3.sinaimg.cn/mw690/c55a7aeejw1f1njlex0x6j208508hgli.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　1. &lt;code&gt;languages&lt;/code&gt;：语言文件包，存放网页语言文件。
　　2. &lt;code&gt;layout&lt;/code&gt;：页面模板文件夹，保存生成静态页面的HTML模板文件，使用的是EJS模板引擎编写，会HTML的话就很容易看懂。
　　3. &lt;code&gt;scripts&lt;/code&gt;：存放网页中要使用的脚本文件。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>3、Hexo博客配置和主题</title>
      <link>/blog/3hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%BB%E9%A2%98/</link>
      <pubDate>Sat, 05 Mar 2016 23:16:49 +0800</pubDate>
      
      <guid>/blog/3hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%BB%E9%A2%98/</guid>
      <description>&lt;p&gt;　　这一篇中，我们介绍一下对Hexo博客的配置，和主题的一些设置。&lt;/p&gt;

&lt;h1 id=&#34;1-博客网站信息配置&#34;&gt;1. 博客网站信息配置&lt;/h1&gt;

&lt;p&gt;　　在创建的博客文件夹根目录(比如我的是E:\Is2Blog),找到名为&lt;code&gt;_config.yml&lt;/code&gt;的配置文件，使用编辑器打开，具体的配置信息说明在下面：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2、安装并部署Hexo博客</title>
      <link>/blog/2%E5%AE%89%E8%A3%85%E5%B9%B6%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sat, 05 Mar 2016 20:46:11 +0800</pubDate>
      
      <guid>/blog/2%E5%AE%89%E8%A3%85%E5%B9%B6%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/</guid>
      <description>&lt;p&gt;　　下面的搭建过程是在Windows系统上进行的，Linux系统和OSX系统可以看&lt;a href=&#34;https://hexo.io/zh-cn/docs/index.html&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;1-安装&#34;&gt;1. 安装&lt;/h1&gt;

&lt;p&gt;　　因为Hexo是基于nodejs编写的，而且使用Git进行管理，所以需要安装这两个工具。
&lt;strong&gt;安装Git工具&lt;/strong&gt;
　　直接百度Git的Windows安装包或者去&lt;a href=&#34;http://git-scm.com/download/&#34;&gt;官网下载&lt;/a&gt;安装，安装过程中无需特殊设置，一路next即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装NodeJs&lt;/strong&gt;
　　nodejs也可以直接去&lt;a href=&#34;http://nodejs.cn/&#34;&gt;中文网&lt;/a&gt;或&lt;a href=&#34;http://nodejs.org/&#34;&gt;英文官网&lt;/a&gt;下载。nodejs有两个版本：LTS(长期支持版)、Stable(稳定版)。建议大家下载LTS长期支持版。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>1、Hexo博客简介</title>
      <link>/blog/1hexo%E5%8D%9A%E5%AE%A2%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 05 Mar 2016 17:55:45 +0800</pubDate>
      
      <guid>/blog/1hexo%E5%8D%9A%E5%AE%A2%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;　　当你点开这篇博客的时候，说明你对写博客是感兴趣的，那就跟着我一起学习搭建自己的博客吧。&lt;/p&gt;

&lt;p&gt;　　首先让我们先探究三个问题：&lt;/p&gt;

&lt;h1 id=&#34;1-为什么要写博客&#34;&gt;1. 为什么要写博客？&lt;/h1&gt;

&lt;p&gt;　　我觉得这个问题应该是很多人不会说，但是心里还是会问的，我为什么要写博客，写博客有什么好处吗？对此我总结了几点：
　　1. 总结
　　　　这是第一点，也是个人认为最重要的一点。我们每天接受的新知识可能非常多，也非常杂，很多时候我们在课堂上或者在看书的时候都是在笔记本上记录零散的知识点，或者在工作开发中将遇到的问题以及解决办法记录下来。但是这些东西对我们来说都是过了一遍罢了，没有起到大的作用。所以我说的总结，就是总结自己学习工作，有一个系统的总结，对我们理解问题有很大的帮助。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我崇拜一个充满激情的鲍尔默</title>
      <link>/%E6%96%87%E9%9B%86/%E6%88%91%E5%B4%87%E6%8B%9C%E4%B8%80%E4%B8%AA%E5%85%85%E6%BB%A1%E6%BF%80%E6%83%85%E7%9A%84%E9%B2%8D%E5%B0%94%E9%BB%98/</link>
      <pubDate>Sat, 05 Mar 2016 12:17:59 +0800</pubDate>
      
      <guid>/%E6%96%87%E9%9B%86/%E6%88%91%E5%B4%87%E6%8B%9C%E4%B8%80%E4%B8%AA%E5%85%85%E6%BB%A1%E6%BF%80%E6%83%85%E7%9A%84%E9%B2%8D%E5%B0%94%E9%BB%98/</guid>
      <description>&lt;p&gt;　　我觉得我可以引入一个副标题：我为什么不崇拜乔布斯。
　　这几年那里见不到用乔布斯熬成的鸡汤，只不过后来多了一碗牛逼哄哄的鸡汤，马云熬的，比较符合人民群众的成功学心理。
　　对于乔布斯我个人没什么特别的崇拜的感觉，觉得他很聪明、很执着、是个天才，有值得我们学习的人生哲理和经验。但是却被很多人熬成一碗人生必备的鸡汤，喝下去的时候，搭配成功学可能效果更佳。
　　在网上我断然是不敢说上面这段话的，因为可能被脑残粉喷成一坨翔。
　　我对乔布斯并不感冒的原因，可能是我个人不太喜欢高冷的人。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>委托使用案例</title>
      <link>/csharp/%E5%A7%94%E6%89%98%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Tue, 01 Mar 2016 23:43:54 +0800</pubDate>
      
      <guid>/csharp/%E5%A7%94%E6%89%98%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</guid>
      <description>&lt;p&gt;把下面集合中字符串小于&lt;code&gt;&amp;quot;6&amp;quot;&lt;/code&gt;的结果查找并打印出来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;List&amp;lt;&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;&amp;gt; strList = &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; List&amp;lt;&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;&amp;gt;() { 
                &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;32&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;7&amp;#34;&lt;/span&gt;
};&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;首先排除掉&lt;code&gt;foreach&lt;/code&gt;等做法，我们使用List集合自带的方法实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;16
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;17
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;18
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;19
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;20
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;21
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;22
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;23
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;24
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;25
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;26
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;27
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;28
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;29
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;30
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;using&lt;/span&gt; System;
&lt;span style=&#34;color:#ff79c6&#34;&gt;using&lt;/span&gt; System.Collections.Generic;
&lt;span style=&#34;color:#ff79c6&#34;&gt;using&lt;/span&gt; System.Linq;

&lt;span style=&#34;color:#ff79c6&#34;&gt;namespace&lt;/span&gt; Delegate7
{
    &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Program&lt;/span&gt;
    {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;void&lt;/span&gt; Main(&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;[]&lt;/span&gt; args)
        {
            List&amp;lt;&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;&amp;gt; strList = &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; List&amp;lt;&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;&amp;gt;()
            {
                &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;32&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;7&amp;#34;&lt;/span&gt;
            };

            &lt;span style=&#34;color:#6272a4&#34;&gt;//&amp;#34;Where&amp;#34;方法的内部执行：遍历strList集合，将集合中的每一个元素拿出来，传入委托去执行，
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#6272a4&#34;&gt;//如果委托返回true，那就把该元素拿出来，然后把所有符合条件的元素组成新的集合返回。
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8be9fd&#34;&gt;var&lt;/span&gt; resultList = strList.Where(
                &lt;span style=&#34;color:#ff79c6&#34;&gt;delegate&lt;/span&gt; (&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; s) 
                {
                    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; s.CompareTo(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;6&amp;#34;&lt;/span&gt;) &amp;lt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;;
                });

            &lt;span style=&#34;color:#ff79c6&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#8be9fd&#34;&gt;var&lt;/span&gt; item &lt;span style=&#34;color:#ff79c6&#34;&gt;in&lt;/span&gt; resultList)
            {
                Console.WriteLine(item);
            }
            Console.ReadKey();
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>委托内部构造</title>
      <link>/csharp/%E5%A7%94%E6%89%98%E5%86%85%E9%83%A8%E6%9E%84%E9%80%A0/</link>
      <pubDate>Tue, 01 Mar 2016 22:37:32 +0800</pubDate>
      
      <guid>/csharp/%E5%A7%94%E6%89%98%E5%86%85%E9%83%A8%E6%9E%84%E9%80%A0/</guid>
      <description>&lt;h1 id=&#34;1-委托的内部构造&#34;&gt;1. 委托的内部构造&lt;/h1&gt;

&lt;p&gt;　　委托的内部构造是什么样的？
　　在一个委托对象被创建后，该委托的内部由三部分组成：&amp;rdquo;_methodPtr(方法指针)&amp;ldquo;、&amp;rdquo;_target(目标对象)&amp;ldquo;、&amp;rdquo;委托链(多播委托时才有，否则为空)&amp;ldquo;，具体的构造我们画张图来看看：
&lt;img src=&#34;http://ww3.sinaimg.cn/mw690/c55a7aeejw1f1hridcavej20is0d874l.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>理解RESTful</title>
      <link>/csharp/%E7%90%86%E8%A7%A3restful/</link>
      <pubDate>Wed, 24 Feb 2016 23:37:09 +0800</pubDate>
      
      <guid>/csharp/%E7%90%86%E8%A7%A3restful/</guid>
      <description>&lt;p&gt;　　在学习Web API之前，我们首先接触的一个概念就是RESTful，个人觉得从名字(英文全名)上来理解还是很抽象的一个概念，刚开始接触的时候感觉似懂非懂，但是使用一段时间后再回来看这个问题就会比较清晰了。
　　在这篇博文中，我尽力把我所理解的RESTful解释清楚，理解错误可能难免，希望有看到的同学能指点一下。&lt;/p&gt;

&lt;p&gt;😒 &lt;strong&gt;简单粗暴版&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>.NET-.NET Core中的配置</title>
      <link>/csharp/net-net-core%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 20 Feb 2016 13:31:43 +0800</pubDate>
      
      <guid>/csharp/net-net-core%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;就在截稿时间之前，Microsoft 宣布了更改 ASP.NET 5 和相关堆叠的名称。ASP.NET 5 已更名为 ASP.NET Core 1.0。Entity Framework (EF) 7 已更名为 Entity Framework (EF) Core 1.0。虽然 ASP.NET 5 和 EF7 程序包以及命名空间将会发生变化，但新的命名法不会对本文中的课程造成任何影响。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用 ASP.NET 5 的同仁们自然都会注意到此平台中新增了配置支持，可用于 NuGet 包的 Microsoft.Extensions.Configuration 集合。&lt;/p&gt;

&lt;p&gt;新的配置支持名称/值对列表（可分入多层层次结构）。例如，您可以将一个设置存储在 SampleApp:Users:InigoMontoya:MaximizeMainWindow 中，将另一个设置存储在 SampleApp:AllUsers:Default:MaximizeMainWindow 中。&lt;/p&gt;

&lt;p&gt;存储的所有值都会映射到字符串，您可以借助内置的绑定支持，将设置反序列化为自定义 POCO 对象。已经熟悉新配置 API 的同仁们可能最初是在 ASP.NET 5 注意到的。不过，此 API 绝不仅限于 ASP.NET。实际上，本文中的所有列表都是使用 Microsoft .NET Framework 4.5.1（同时引用 ASP.NET 5 RC1 中的 Microsoft.Extensions.Configuration 包）在 Visual Studio 2015 单元测试项目中创建（有关源代码，请访问 &lt;a href=&#34;http://github.com/IntelliTect/Articles&#34;&gt;gitHub.com/IntelliTect/Articles&lt;/a&gt;）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>数据点-重构ASP.NET5/EF6项目和依赖关系注入</title>
      <link>/csharp/%E6%95%B0%E6%8D%AE%E7%82%B9-%E9%87%8D%E6%9E%84asp-net5-ef6%E9%A1%B9%E7%9B%AE%E5%92%8C%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Tue, 16 Feb 2016 13:05:29 +0800</pubDate>
      
      <guid>/csharp/%E6%95%B0%E6%8D%AE%E7%82%B9-%E9%87%8D%E6%9E%84asp-net5-ef6%E9%A1%B9%E7%9B%AE%E5%92%8C%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%B3%A8%E5%85%A5/</guid>
      <description>&lt;p&gt;就在截稿时间之前，Microsoft 宣布了更改 ASP.NET 5 和相关堆叠的名称。ASP.NET 5 已更名为 ASP.NET Core 1.0。Entity Framework (EF) 7 已更名为 Entity Framework (EF) Core 1.0。虽然 ASP.NET 5 和 EF7 程序包以及命名空间将会发生变化，但新的命名法不会对本文中的课程造成任何影响。&lt;/p&gt;

&lt;p&gt;依赖关系注入 (DI) 都是关于松耦合的 (&lt;a href=&#34;http://bit.ly/1TZWVtW&#34;&gt;bit.ly/1TZWVtW&lt;/a&gt;。您从其他位置（理想情况下是类构造函数）请求获取您依赖的类，而不是将这些类硬编码为其他类。这遵循的是显式依赖关系原则，可以更明确地告知类用户此类所需的协作者。这样一来，您还可以在类对象实例有备选配置的情况下构建更灵活的软件，同时这也对编写这种类的自动测试真正有益。我的工作领域就是和 Entity Framework代码不停地打交道。典型的例子是：在不使用松耦合的情况下编码就是在创建可直接实例化 DbContext 的存储库或控制器。我已经上千次这样做过。实际上，我撰写这篇文章的目标是为了向我在专栏“EF6、EF7 与 ASP.NET 5 组合”(&lt;a href=&#34;http://msdn.com/magazine/dn973011&#34;&gt;msdn.com/magazine/dn973011&lt;/a&gt;) 中编写的代码应用我所学到的 DI知识。例如，在下面的方法中，我就直接实例化了 DbContext：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>红包的艺术</title>
      <link>/%E6%96%87%E9%9B%86/%E7%BA%A2%E5%8C%85%E7%9A%84%E8%89%BA%E6%9C%AF/</link>
      <pubDate>Sat, 13 Feb 2016 00:12:45 +0800</pubDate>
      
      <guid>/%E6%96%87%E9%9B%86/%E7%BA%A2%E5%8C%85%E7%9A%84%E8%89%BA%E6%9C%AF/</guid>
      <description>&lt;p&gt;　　微信的牛逼之处在于人多(用户)，支付宝的牛逼之处在于钱多(银行卡)。
　　这两家国内的大公司为了圈用户大搞红包的艺术，玩法多样，在微信这个国内爆炸式增长的社交平台上更是如鱼得水。所以这出也没少得了支付宝，这个有钱没人(社交)的平台想了一个绝佳的主意————敬业福，敬业福有多火？来来，看个段子就知道了：
　　丈母娘：“你有车吗？有房吗？有存款吗？”
　　准女婿：“没有。”
　　丈母娘：“那你怎么还有脸来我家提亲？”
　　准女婿：“我有一张敬业福。”
　　丈母娘：“来来来，快进来坐，喝茶咱们慢慢聊。”
　　&amp;hellip;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Git速查表大全</title>
      <link>/tool/git%E9%80%9F%E6%9F%A5%E8%A1%A8%E5%A4%A7%E5%85%A8/</link>
      <pubDate>Fri, 12 Feb 2016 22:06:36 +0800</pubDate>
      
      <guid>/tool/git%E9%80%9F%E6%9F%A5%E8%A1%A8%E5%A4%A7%E5%85%A8/</guid>
      <description>&lt;p&gt;题图来自&lt;a href=&#34;http://www.imooc.com&#34;&gt;慕课网&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-git常用命令速查表&#34;&gt;1. Git常用命令速查表&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/mw690/c55a7aeejw1f1d54uf2jkj21kw146tqg.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>string类常用函数和属性</title>
      <link>/csharp/string%E7%B1%BB%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 03 Feb 2016 01:25:40 +0800</pubDate>
      
      <guid>/csharp/string%E7%B1%BB%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h1 id=&#34;1-字符串的特殊性&#34;&gt;1. 字符串的特殊性&lt;/h1&gt;

&lt;p&gt;　　1、字符串的不可变性，当我们在给字符串进行重新赋值、拼接、累加的过程中，都会在内存的堆空间中重新开辟一块新的空间。
　　2、我们可以将字符串看做是一个&lt;code&gt;char&lt;/code&gt;类型的数组。&lt;/p&gt;

&lt;h1 id=&#34;2-字符串常用函数&#34;&gt;2. 字符串常用函数：&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;ToCharArray();&lt;/code&gt; 将字符串转换成一个char类型的数组：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>已去的2015</title>
      <link>/%E6%96%87%E9%9B%86/%E5%B7%B2%E5%8E%BB%E7%9A%842015/</link>
      <pubDate>Wed, 27 Jan 2016 00:14:37 +0800</pubDate>
      
      <guid>/%E6%96%87%E9%9B%86/%E5%B7%B2%E5%8E%BB%E7%9A%842015/</guid>
      <description>&lt;p&gt;　　我都不知道怎么感叹时间走的这么快了，不过那些被用烂了的词应该足以表达我想表达的意思，但是我还是想对着天空大喊一声，大海啊全是水，骏马啊四条腿，时间啊过的真他娘的快……
　　猴年将至，我又要被贴上“本命年”的标签，不过这个标签比较沉重，记得上一次被贴上这玩意的时候，我还是个孩子啊卧槽。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>抽象工厂模式(Abstract Factory)：抽象工厂</title>
      <link>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-abstract-factory-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</link>
      <pubDate>Sat, 23 Jan 2016 17:12:30 +0800</pubDate>
      
      <guid>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-abstract-factory-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;提供一个接口，让该接口负责创建一系列“相关或相互依赖的对象”，无需指定他们的具体类。      ————GoF&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　在抽象工厂中有两种抽象存在：系列的抽象、产品的抽象。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>抽象工厂模式(Abstract Factory)：工厂方法</title>
      <link>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-abstract-factory-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 23 Jan 2016 00:10:49 +0800</pubDate>
      
      <guid>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-abstract-factory-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;　　学习抽象工厂之前，我们有必要对另外两个：简单工厂、工厂方法进行学习，以更好的掌握抽象工厂的使用。
&amp;gt;定义一个用于创建对象的接口，让子类决定实例化哪一个产品，Factory Method使得一个产品类的实例化延迟到子类。  ————GoF&lt;/p&gt;

&lt;p&gt;　　 在软件系统中经常面临着某个对象(产品)的创建工作由于需求的变化，这个对象(产品)经常面临中剧烈的变化，但是他却拥有比较稳定的接口。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>hexo免输入用户名密码部署到github的方法</title>
      <link>/blog/hexo%E5%85%8D%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%83%A8%E7%BD%B2%E5%88%B0github%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 22 Jan 2016 23:34:58 +0800</pubDate>
      
      <guid>/blog/hexo%E5%85%8D%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%83%A8%E7%BD%B2%E5%88%B0github%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;　　最近一直在写博客和修改主题样式，因为需要即时发布，所以没有使用&lt;code&gt;hexo s&lt;/code&gt;本地预览,需要反复的执行&lt;code&gt;hexo d -g&lt;/code&gt;来发布预览效果，但是每次都需要输入*username*和*password*，非常麻烦，想到在使用git时可以设置SSH来免输入账号密码，所以试了试，但是好像没什么用，所以google了一下，找到了解决办法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>抽象工厂模式(Abstract Factory)：简单工厂</title>
      <link>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-abstract-factory%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</link>
      <pubDate>Fri, 15 Jan 2016 17:28:48 +0800</pubDate>
      
      <guid>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-abstract-factory%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</guid>
      <description>&lt;p&gt;　　学习抽象工厂之前，我们有必要对另外两个：简单工厂、工厂方法进行学习，以更好的掌握抽象工厂的使用。&lt;/p&gt;

&lt;h1 id=&#34;1-简单工厂&#34;&gt;1. 简单工厂&lt;/h1&gt;

&lt;p&gt;　　简单工厂并不是一种模式，而是面向对象方式的一种体现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《心迷宫》</title>
      <link>/%E6%96%87%E9%9B%86/%E5%BF%83%E8%BF%B7%E5%AE%AB/</link>
      <pubDate>Fri, 15 Jan 2016 12:02:23 +0800</pubDate>
      
      <guid>/%E6%96%87%E9%9B%86/%E5%BF%83%E8%BF%B7%E5%AE%AB/</guid>
      <description>&lt;p&gt;　　被暴走看啥片安利过来看这部片子的，不然可能我不会花时间去看这部不卖座也没有大牌演技派出演的电影。当然除去演员摄影等硬性部分，这个故事确实很精彩。&lt;/p&gt;

&lt;p&gt;　　故事由一具死尸贯穿全剧，牵引出村子里每个人的“心事”。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《火影忍者：博人传》</title>
      <link>/%E6%96%87%E9%9B%86/%E7%81%AB%E5%BD%B1%E5%BF%8D%E8%80%85%E5%8D%9A%E4%BA%BA%E4%BC%A0/</link>
      <pubDate>Thu, 14 Jan 2016 17:36:11 +0800</pubDate>
      
      <guid>/%E6%96%87%E9%9B%86/%E7%81%AB%E5%BD%B1%E5%BF%8D%E8%80%85%E5%8D%9A%E4%BA%BA%E4%BC%A0/</guid>
      <description>&lt;p&gt;　　火影完结了，那个要做火影的男人的故事也结束了，上一次看火影剧场版还是几个月前的事情，那时是舍不得看，因为看完，这个故事也这么完了……
　　但是看完《博人传》感觉故事还没有完，起码突然感觉我的人生还在继续。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>适配器模式(Adapter)</title>
      <link>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-adapter/</link>
      <pubDate>Tue, 12 Jan 2016 20:52:41 +0800</pubDate>
      
      <guid>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-adapter/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;将一个类的接口转换成客户希望的另一个接口。Adapter模式是将原本由于接口不兼容而不能工作在一起的那些类可以在一起工作。       ————GoF&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　在软件系统中，由于应用环境的变化，常常需要将一些老的系统放在新的系统中使用，但是新的系统要求的接口和老的系统不一致，这就需要一个中间的适配器去将新老系统转换连接，使之能够正常工作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>单例模式(Singleton)</title>
      <link>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-singleton/</link>
      <pubDate>Mon, 11 Jan 2016 11:26:52 +0800</pubDate>
      
      <guid>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-singleton/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;保证一个类仅有一个实例，并且提供一个该实例的全局访问点。     ————GoF　　&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　
　　在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。
　　用户不能随便的使用*new*去创建一个类，这应该是设计者应该控制的。
&lt;img src=&#34;/image/Design Pattern/design pattern1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>面向对象设计模式与原则</title>
      <link>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 10 Jan 2016 23:22:53 +0800</pubDate>
      
      <guid>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。  ————Chistopher Alexander&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　设计模式描述了软件设计过程中一些常见问题的一般性解决方案。
　　面向对象设计模式描述了面向对象设计过程中、特定场景下、类与相互通信的对象之间常见的组织关系。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>11、Umbraco入门总结</title>
      <link>/csharp/11umbraco%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 10 Jan 2016 14:05:19 +0800</pubDate>
      
      <guid>/csharp/11umbraco%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;　　Umbraco入门教程算是告一段落了，其实将其称为“教程”，我觉得有些惭愧，因为其中并没有什么干货，编码也不是很好，所以在这里跟大家说句抱歉，也请朋友们不要见怪，暂且称其为“教程”吧，也希望能够认识更多的朋友，大家互相学习。&lt;/p&gt;

&lt;p&gt;　　这些在Umbraco的使用中是最基本的使用方法，Umbraco是非常强大的，我目前掌握的还只是皮毛罢了，在这里只是希望给自己记个笔记，如果能帮到刚刚接触到Umbraco的朋友，那就万幸的。如果有时间和精力，我会继续写一些关于Umbraco的高级一点的用法，我自己也会努力学习，学习是无止境的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>10、UmbracoNewsSite：首页新闻聚合</title>
      <link>/csharp/10umbraconewssite%E9%A6%96%E9%A1%B5%E6%96%B0%E9%97%BB%E8%81%9A%E5%90%88/</link>
      <pubDate>Sun, 10 Jan 2016 12:56:07 +0800</pubDate>
      
      <guid>/csharp/10umbraconewssite%E9%A6%96%E9%A1%B5%E6%96%B0%E9%97%BB%E8%81%9A%E5%90%88/</guid>
      <description>&lt;p&gt;　　目前为止已经实现了基本的新闻展示和新闻内容添加管理的功能演示，这一篇是Umbraco入门的最后一篇教程，我们看看怎么在首页拿到其他页面的数据的。&lt;/p&gt;

&lt;p&gt;　　要在首页拿到几个新闻板块的节点，然后分别读取最新的新闻数据显示在首页中。
　　我们需要在&lt;strong&gt;Home&lt;/strong&gt;模板中进行编写代码，具体的代码如下：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《一个勺子》</title>
      <link>/%E6%96%87%E9%9B%86/%E4%B8%80%E4%B8%AA%E5%8B%BA%E5%AD%90/</link>
      <pubDate>Sat, 09 Jan 2016 22:56:15 +0800</pubDate>
      
      <guid>/%E6%96%87%E9%9B%86/%E4%B8%80%E4%B8%AA%E5%8B%BA%E5%AD%90/</guid>
      <description>&lt;p&gt;　　没想到这是陈建斌的导演处女作，竟然如他的演技一般老练。&lt;/p&gt;

&lt;p&gt;　　“勺子”在西北方言里面是傻子的意思，在影片一开始的时候便拿出了这条百度百科的词条。这时才想起来，原来百度不仅能帮骗子卖假药，而且还能帮忙解释解释“勺子”的含义。
　　故事由主人公“拉条子”捡回一个傻子开头，由此上演了一出好人、骗子、傻子的黑色幽默。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>9、UmbracoNewsSite：分页</title>
      <link>/csharp/9umbraconewssite%E5%88%86%E9%A1%B5/</link>
      <pubDate>Sat, 09 Jan 2016 13:54:45 +0800</pubDate>
      
      <guid>/csharp/9umbraconewssite%E5%88%86%E9%A1%B5/</guid>
      <description>&lt;p&gt;　　接着上一篇博客的内容，这一篇我们开始给新闻列表进行分页。&lt;/p&gt;

&lt;p&gt;　　首先说一下分页的思路，由于Umbraco使用的是模板的结构，所以我们需要将分页的页码数发送到当前的页面中，然后拿到这个页码数，对应的进行读取对应页码的新闻。
　　首先给当前的新闻分类添加了10条新闻，然后按照每页显示3条来进行分页。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>8、UmbracoNewsSite：添加新闻列表</title>
      <link>/csharp/8umbraconewssite%E6%B7%BB%E5%8A%A0%E6%96%B0%E9%97%BB%E5%88%97%E8%A1%A8/</link>
      <pubDate>Fri, 08 Jan 2016 12:20:45 +0800</pubDate>
      
      <guid>/csharp/8umbraconewssite%E6%B7%BB%E5%8A%A0%E6%96%B0%E9%97%BB%E5%88%97%E8%A1%A8/</guid>
      <description>&lt;p&gt;　　在上一篇中添加了新闻详情页面，但是没有任何可以指向这条新闻内容的跳转，所以需要将新闻添加到新闻列表中展示。&lt;/p&gt;

&lt;p&gt;　　现在我们找到&lt;strong&gt;News List&lt;/strong&gt;模板，对其中的代码进行编辑，以展示新闻列表。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>7、UmbracoNewsSite：新闻详情页</title>
      <link>/csharp/7umbraconewssite%E6%96%B0%E9%97%BB%E8%AF%A6%E6%83%85%E9%A1%B5%E5%92%8C%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA/</link>
      <pubDate>Thu, 07 Jan 2016 21:53:36 +0800</pubDate>
      
      <guid>/csharp/7umbraconewssite%E6%96%B0%E9%97%BB%E8%AF%A6%E6%83%85%E9%A1%B5%E5%92%8C%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA/</guid>
      <description>&lt;p&gt;　　这一篇我们创建一个新闻详情页文档类型，然后尝试编辑新闻内容。&lt;/p&gt;

&lt;p&gt;　　首先确定新闻详情页需要什么？应该有新闻标题、新闻内容、新闻简介、新闻缩略图；其中后两个是为了在新闻列表展示该新闻信息设置的。确定了这些，现在就可以开始编写了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>6、UmbracoNewsSite：添加新闻分类</title>
      <link>/csharp/6umbraconewssite%E6%B7%BB%E5%8A%A0%E6%96%B0%E9%97%BB%E5%88%86%E7%B1%BB/</link>
      <pubDate>Wed, 06 Jan 2016 16:21:30 +0800</pubDate>
      
      <guid>/csharp/6umbraconewssite%E6%B7%BB%E5%8A%A0%E6%96%B0%E9%97%BB%E5%88%86%E7%B1%BB/</guid>
      <description>&lt;p&gt;　　上一篇做了一个简单的首页，在导航条上添加了几个新闻板块，接下来我们就添加这几个新闻板块的页面。&lt;/p&gt;

&lt;p&gt;　　开始我们还是需要创建&lt;strong&gt;Document Types&lt;/strong&gt;用来展示新闻列表。我们先做好规划，新闻列表只需要把新闻标题和图片展示出来就可以了，。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>5、UmbracoNewsSite：添加css和js文件</title>
      <link>/csharp/5umbraconewssite%E6%B7%BB%E5%8A%A0%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9/</link>
      <pubDate>Tue, 05 Jan 2016 10:41:40 +0800</pubDate>
      
      <guid>/csharp/5umbraconewssite%E6%B7%BB%E5%8A%A0%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9/</guid>
      <description>我们接着上一篇的内容，这一篇我们引入stylesheets样式，并且尝试添加其他页面的内容。
　打开visual studio，在项目根目录下新建js和css文件夹，分别把bootstrap的文件复制进去。(如果已经有就不用新建了) 然后打开Umbraco后台管理页面，刷新之后就可以看到Stylesheets节点下面出现了刚刚复制的文件。这是因为Umbraco规定了Stylesheet节点默认去读取根目录下名为*css*的文件夹中的文件；看到这你可能会下意识的认为那Scripts节点下肯定会出现刚才复制的js脚本文件啦！事实是——没有！Scripts节点默认读取的文件夹名是*scripts*，所以在引用这些文件的时候要注意路径。
　文件添加完毕了，我们在程序中引用文件，在Templates节点下打开Master文件，然后将bootstrap文件分别添加进去(这里需要注意路径)。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;zh-cn&amp;#34;&amp;gt; &amp;lt;head&amp;gt; ...... &amp;lt;!-- CSS --&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;/css/bootstrap.min.css&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; ....... &amp;lt;!-- Javascripts --&amp;gt; &amp;lt;script src=&amp;#34;/js/jquery.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;/js/bootstrap.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   　接下来我们进入编码工作，为了方便编写代码，可以进入visual studio进行编写，在Umbraco后台创建的文件内容在源代码中都可以找到，其中Templates节点下的文件在VS项目中的Views文件夹下，这下MVC模式就可以体现出来了。为了演示，我会继续在网页后台写代码，这个没有特别的限制。 　我们把*Master*模板代码改动一下，让页面稍微好看一点。代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  @inherits Umbraco.</description>
    </item>
    
    <item>
      <title>4、UmbracoNewsSite：Templates展示内容数据</title>
      <link>/csharp/4umbraconewssitetemplates%E5%B1%95%E7%A4%BA%E5%86%85%E5%AE%B9%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 04 Jan 2016 16:45:02 +0800</pubDate>
      
      <guid>/csharp/4umbraconewssitetemplates%E5%B1%95%E7%A4%BA%E5%86%85%E5%AE%B9%E6%95%B0%E6%8D%AE/</guid>
      <description>&lt;p&gt;　　接着上一篇博客内容，这一篇我们来看看怎么把设置好的数据展示在网页上面。&lt;/p&gt;

&lt;p&gt;　　因为Umbraco是基于MVC编写的软件，我们也最好遵循这个方式，也就是一个模板页(master)，然后再使用部分页(partial view)展示具体的内容。这里的模板需要创建在&lt;strong&gt;Setting&amp;ndash;&amp;gt;Templates&lt;/strong&gt;节点下面。我们打开&lt;strong&gt;Templates&lt;/strong&gt;节点，可以看到我们创建的Home模板已经在这里了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>3、UmbracoNewsSite：文档类型设置</title>
      <link>/csharp/3umbraconewssite-%E4%B8%80/</link>
      <pubDate>Sun, 03 Jan 2016 13:37:04 +0800</pubDate>
      
      <guid>/csharp/3umbraconewssite-%E4%B8%80/</guid>
      <description>&lt;p&gt;　　从这一篇开始，我们制作一个简单的新闻网站UmbracoNewsStie，用来演示Umbraco的实际使用技巧。&lt;/p&gt;

&lt;p&gt;　　在开始，我们需要先创建文档类型才能进行其他的操作，文档类型就是网站要展示什么。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2、Umbraco后台管理功能介绍</title>
      <link>/csharp/umbraco%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sat, 02 Jan 2016 11:13:41 +0800</pubDate>
      
      <guid>/csharp/umbraco%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</guid>
      <description>&lt;p&gt;　　上一篇博客介绍了Umbraco的安装，这一篇里面介绍一下umbraco的后台管理的一些主要功能的使用方式。
　　首先介绍一下侧边栏的几个主要功能：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>1、Umbraco简介和安装</title>
      <link>/csharp/umbraco%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Fri, 01 Jan 2016 21:23:04 +0800</pubDate>
      
      <guid>/csharp/umbraco%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;　　Umbraco是国外一个开源的Cms(内容管理)系统，适合做新闻发布、官网等内容需要经常更改变动的网站，也可以作为论坛软件使用，比如asp.net论坛就是基于umbraco制作的。而且Umbraco是使用“所见即所得”的形式，对网站的控制更加方便简单。可谓分分钟做出一个功能齐全的网站的节奏。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git知识点总结</title>
      <link>/tool/git%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 14 Oct 2015 20:30:45 +0800</pubDate>
      
      <guid>/tool/git%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;&lt;strong&gt;对git的理解&lt;/strong&gt;：
　　1、git跟踪的不是文件，而是修改，这就是git优秀而且快速的原因。
　　2、当你从远程克隆的时候，其实就是把git本地的master分支和远程的master分支对应起来了，远程仓库的默认名称是*origin*。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《九层妖塔》</title>
      <link>/%E6%96%87%E9%9B%86/%E4%B9%9D%E5%B1%82%E5%A6%96%E5%A1%94/</link>
      <pubDate>Tue, 06 Oct 2015 23:31:13 +0800</pubDate>
      
      <guid>/%E6%96%87%E9%9B%86/%E4%B9%9D%E5%B1%82%E5%A6%96%E5%A1%94/</guid>
      <description>&lt;p&gt;　　史上最难看、史上最难看、最难看的电影《九层妖塔》上映了，王八蛋导演坑蒙拐骗了好几亿票房，带着他的脑残编剧跑了，观众没有办法，编几个段子消消气，原来一两句能泄愤的，现在通通省略N句脏话，现在通通省略N句脏话，导演王八蛋，你不是人，我们好心好意看个《鬼吹灯》，被你毁成这样，你还我58块电影票钱，你还我58块电影票钱！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MVC延伸：MVP、MVVM</title>
      <link>/csharp/mvc%E5%BB%B6%E4%BC%B8mvpmvvm/</link>
      <pubDate>Sat, 19 Sep 2015 01:16:16 +0800</pubDate>
      
      <guid>/csharp/mvc%E5%BB%B6%E4%BC%B8mvpmvvm/</guid>
      <description>&lt;p&gt;　　学习和使用ASP.NET MVC也有一段时间了，对这种开发方式(模式)有了更进一步的了解，今天就跳出ASP.NET的圈子，说一说我了解到的MVC，以及延伸到的MVP、MVVM。(如果理解的不到位希望有看到的这篇博文的同学在评论中指出😛)&lt;/p&gt;

&lt;h1 id=&#34;1-mvc&#34;&gt;1. MVC&lt;/h1&gt;

&lt;p&gt;　　一开始接触MVC时最先想到的是，MVC算不算是一种设计模式？为什么GoF的23种设计模式中没有MVC模式？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HTML辅助方法</title>
      <link>/csharp/html%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 02 Aug 2015 23:15:02 +0800</pubDate>
      
      <guid>/csharp/html%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;　　HTML辅助方法，也就是&lt;code&gt;HtmlHelper&lt;/code&gt;，就是帮助快捷的产生HTML标签的作用。
　　HTML辅助方法可以编写超链接、表单(&lt;form&gt;)、输入框、选项、加载其他的分布视图(Partial View)等。&lt;/p&gt;

&lt;h1 id=&#34;1-超链接-html-actionlink&#34;&gt;1. 超链接：Html.ActionLink&lt;/h1&gt;

&lt;p&gt;　　&lt;code&gt;@Html.ActionLink()&lt;/code&gt;用于产生超链接。并且链接的文字部分会自动的进行HTML编码(HtmlEncode)。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>directive中写template遇见的问题</title>
      <link>/frontend/directive%E4%B8%AD%E5%86%99template%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 18 Jul 2015 23:51:57 +0800</pubDate>
      
      <guid>/frontend/directive%E4%B8%AD%E5%86%99template%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;　　记录一下先前在写指令时，遇到的一个令人无语的错误，避免以后重犯。&lt;/p&gt;

&lt;p&gt;　　错误的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;app.directive( &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39; ckqlnfo&amp;#39;&lt;/span&gt; ,[&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(){
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; {
    　　　restrict&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39; AE &amp;#39;&lt;/span&gt; 
    　　　replace: &lt;span style=&#34;color:#8be9fd&#34;&gt;true&lt;/span&gt;, 
    　　　template &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;&amp;lt;p&amp;gt;模板&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;模板&amp;lt;/p&amp;gt; &amp;#39;&lt;/span&gt; 
        ｝
    ｝&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>angular.module()的简单使用</title>
      <link>/frontend/angular-module-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 13 Jul 2015 23:17:26 +0800</pubDate>
      
      <guid>/frontend/angular-module-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;p&gt;　　今天记录一下angularJS的核心入口ng-module。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; myApp&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;angular.module(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;app&amp;#39;&lt;/span&gt;,[]); //创建ng-app的模型&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　这一句是我们写AngularJS代码的入口，也是基础知识。整个文件或者项目的运行就是基于这个方法得以继续的。在AngularJS的源代码中&lt;code&gt;module&lt;/code&gt;方法是作为一个方法函数赋值给了&lt;code&gt;angular&lt;/code&gt;这个全局对象的，所以有&lt;code&gt;angular&lt;/code&gt;这个顶层对象直接调用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>反射(reflection)</title>
      <link>/csharp/%E5%8F%8D%E5%B0%84-reflection/</link>
      <pubDate>Thu, 18 Jun 2015 16:01:14 +0800</pubDate>
      
      <guid>/csharp/%E5%8F%8D%E5%B0%84-reflection/</guid>
      <description>&lt;h1 id=&#34;1-什么是反射&#34;&gt;1. 什么是反射&lt;/h1&gt;

&lt;p&gt;　　一个运行的程序查看本身或者其他程序的元数据的行为称为反射(reflection)。
　　元数据(metadata)：有关程序及其类型的数据称为元数据，它们保存在程序的程序集中。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;反射功能引用自system.Reflection命名空间&lt;/strong&gt;，要使用反射需要使用&lt;code&gt;System.Reflection&lt;/code&gt;命名空间。
　　BCL(基类库)声明了一个叫做&lt;code&gt;Type&lt;/code&gt;的抽象类，它被设计用来包含类型的特性，使用这个类的对象能让我们获取程序使用的类型的信息。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>数组(array)</title>
      <link>/csharp/%E6%95%B0%E7%BB%84-array/</link>
      <pubDate>Sun, 07 Jun 2015 00:20:12 +0800</pubDate>
      
      <guid>/csharp/%E6%95%B0%E7%BB%84-array/</guid>
      <description>&lt;h1 id=&#34;1-数组&#34;&gt;1. 数组&lt;/h1&gt;

&lt;p&gt;　　&lt;strong&gt;数组实际上是由一个变量名称表示的一组同类型的数据元素&lt;/strong&gt;，每一个元素都可以通过变量名称和一个或多个方括号中的索引名称来访问，例如：&lt;code&gt;MyArray[1]&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&#34;2-定义&#34;&gt;2. 定义&lt;/h1&gt;

&lt;p&gt;　　■ 元素：数组中&lt;strong&gt;独立的数据项&lt;/strong&gt;被称为元素。数组的所有元素必须是相同类型的，或继承自相同的类型。
　　■ 秩/维度：数组可以有任何为正数的维度数(也就是几维数组的意思，例如二维数组的秩等于2)，数组的维度数称为秩(rank)。
　　■ 维度长度：数组的每一个维度有一个长度，就是这个方向的位置个数。
　　■ 数组长度：数组的所有维度中的元素的总和称为数组的长度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>枚举(enumerate)</title>
      <link>/csharp/%E6%9E%9A%E4%B8%BE-enumerate/</link>
      <pubDate>Thu, 04 Jun 2015 23:14:38 +0800</pubDate>
      
      <guid>/csharp/%E6%9E%9A%E4%B8%BE-enumerate/</guid>
      <description>&lt;h1 id=&#34;1-什么是枚举&#34;&gt;1. 什么是枚举&lt;/h1&gt;

&lt;p&gt;　　枚举是程序员自己定义的类型，与类和结构一样。
　　■ 与结构一样，枚举是值类型，因此直接存储它们的数据，而不是分成引用和数据去存储。
　　■ 不能对枚举成员使用修饰符，它们都隐式的具有和枚举相同的可访问性。
　　■ 枚举只有一种类型的成员：命名的整数值常量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//声明枚举的关键字是“enum”
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;enum&lt;/span&gt; TrafficLight
{
    Green,  &lt;span style=&#34;color:#6272a4&#34;&gt;//成员之间用逗号分隔
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    Yellow,  
    Red
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>接口(interface)</title>
      <link>/csharp/%E6%8E%A5%E5%8F%A3-interface/</link>
      <pubDate>Wed, 03 Jun 2015 01:08:11 +0800</pubDate>
      
      <guid>/csharp/%E6%8E%A5%E5%8F%A3-interface/</guid>
      <description>&lt;h1 id=&#34;1-什么是接口&#34;&gt;1. 什么是接口&lt;/h1&gt;

&lt;p&gt;　　接口是一种能力的体现。
　　接口是表示一组&lt;strong&gt;函数成员&lt;/strong&gt;而不是实现成员的引用类型，类和结构可以实现接口。&lt;/p&gt;

&lt;h1 id=&#34;2-声明接口&#34;&gt;2. 声明接口&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//声明接口的关键字是“interface”
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;interface&lt;/span&gt; IMyInterface
{
    &lt;span style=&#34;color:#6272a4&#34;&gt;//接口中的方法没有方法体(也就是没有具体的实现)
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; GetSum(&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; num1,&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; num2); 
    &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; Speak(&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; str);
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>结构(struct)</title>
      <link>/csharp/%E7%BB%93%E6%9E%84-struct/</link>
      <pubDate>Sun, 24 May 2015 23:26:37 +0800</pubDate>
      
      <guid>/csharp/%E7%BB%93%E6%9E%84-struct/</guid>
      <description>&lt;h1 id=&#34;1-什么是结构&#34;&gt;1. 什么是结构&lt;/h1&gt;

&lt;p&gt;　　结构是程序员定义的数据类型，非常类似于类，都有数据成员和函数成员。
　　结构就是轻量级的类，使用方式和枚举差不多，方便归类存储数据。
　　结构和类的区别是：
　　■ 类是引用类型而结构是值类型。
　　■ 结构是隐式密封的，这意味着结构不能被派生。
&lt;strong&gt;声明结构&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//声明结构的关键字是“struct”
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;StructName&lt;/span&gt;
{
    MemberDeclarations
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>泛型(generic)</title>
      <link>/csharp/%E6%B3%9B%E5%9E%8B-generic/</link>
      <pubDate>Fri, 22 May 2015 16:17:54 +0800</pubDate>
      
      <guid>/csharp/%E6%B3%9B%E5%9E%8B-generic/</guid>
      <description>&lt;h1 id=&#34;1-什么是泛型&#34;&gt;1. 什么是泛型&lt;/h1&gt;

&lt;p&gt;　　我们平常所用到的类型都是特定的类型——由编程语言或者BCL(基类库)、程序员自己定义的。为了让代码更加的灵活、解耦，我们可以将类的行为提取出来，使这些相似性的特征不仅可以用在当前的数据类型上，而且还可以扩展到其他的类型上，这样使类更加的有用。
　　泛型就是专门处理这种情况的，泛型就可以替代这种抽象的数据类型，泛型就相当于是类型的占位符。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>事件(Event)</title>
      <link>/csharp/%E4%BA%8B%E4%BB%B6-event/</link>
      <pubDate>Thu, 21 May 2015 23:07:00 +0800</pubDate>
      
      <guid>/csharp/%E4%BA%8B%E4%BB%B6-event/</guid>
      <description>&lt;h1 id=&#34;1-事件是什么&#34;&gt;1. 事件是什么&lt;/h1&gt;

&lt;p&gt;　　事件是对象与对象之间的通信工具。
　　事件的很多方面和委托相似，事件就好像是被简化后的针对特殊用途的委托。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>委托(delegate)</title>
      <link>/csharp/%E5%A7%94%E6%89%98-delegate/</link>
      <pubDate>Wed, 20 May 2015 16:47:52 +0800</pubDate>
      
      <guid>/csharp/%E5%A7%94%E6%89%98-delegate/</guid>
      <description>&lt;h1 id=&#34;1-什么是委托&#34;&gt;1. 什么是委托&lt;/h1&gt;

&lt;p&gt;　　&lt;strong&gt;委托&lt;/strong&gt;是一个包含具有相同签名和返回值类型的有序方法列表。
　　■ 方法的列表称为&lt;strong&gt;调用列表&lt;/strong&gt;(invocation list)
　　■ 当委托被调用时，它调用列表中的每一个方法。
&lt;img src=&#34;/image/cSharp/cSharp31.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>异常(try语句)</title>
      <link>/csharp/%E5%BC%82%E5%B8%B8-try%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Tue, 19 May 2015 17:29:08 +0800</pubDate>
      
      <guid>/csharp/%E5%BC%82%E5%B8%B8-try%E8%AF%AD%E5%8F%A5/</guid>
      <description>&lt;h1 id=&#34;1-什么是异常&#34;&gt;1. 什么是异常&lt;/h1&gt;

&lt;p&gt;　　&lt;strong&gt;异常&lt;/strong&gt;是程序中的运行时错误，它违反了一个系统的约束或应用程序约束，或出现了在正常操作是位于聊的情形。&lt;/p&gt;

&lt;h1 id=&#34;2-try语句&#34;&gt;2. try语句&lt;/h1&gt;

&lt;p&gt;　　&lt;strong&gt;try&lt;/strong&gt;语句用来包裹住可能发生异常的代码块，如果异常发生的话，就提供代码处理该异常。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>c#类型、存储和变量</title>
      <link>/csharp/c-%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E5%92%8C%E5%8F%98%E9%87%8F/</link>
      <pubDate>Wed, 13 May 2015 22:02:53 +0800</pubDate>
      
      <guid>/csharp/c-%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E5%92%8C%E5%8F%98%E9%87%8F/</guid>
      <description>&lt;p&gt;&lt;strong&gt;c#程序是一组类型声明&lt;/strong&gt;
　　如果广泛的描述C和C++程序源代码的特征，可以说C程序是一组函数数据类型，C++程序是一组函数和类，然而c#程序是一组类型声明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类型是一种模板&lt;/strong&gt;
　　既然c#程序是一组类型声明，那么使用c#就是创建和使用类型。
　　可以把类型想象成一个用来创建数据结构的模板。这个模板本身不是数据结构，但是详细说明了由该模板构造的对象的特征：
&lt;img src=&#34;/image/cSharp/cSharp8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>c#和.NET框架</title>
      <link>/csharp/c-%E5%92%8C-net%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Tue, 12 May 2015 00:24:34 +0800</pubDate>
      
      <guid>/csharp/c-%E5%92%8C-net%E6%A1%86%E6%9E%B6/</guid>
      <description>&lt;p&gt;&lt;strong&gt;.NET框架的组成&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;　　.NET由三部分组成，如图所示：
&lt;img src=&#34;/image/cSharp/cSharp1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SQL Server视图</title>
      <link>/database/sql-server%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Mon, 27 Apr 2015 16:57:47 +0800</pubDate>
      
      <guid>/database/sql-server%E8%A7%86%E5%9B%BE/</guid>
      <description>&lt;h1 id=&#34;什么是视图&#34;&gt;什么是视图&lt;/h1&gt;

&lt;p&gt;　　视图就是一张虚拟表，是基于SQL语句的&lt;strong&gt;结果集&lt;/strong&gt;的可视化的表，视图中的字段是来自一个或多个表中的字段(相当于子查询的结果集那样)。
　　视图简单的理解为一个统一访问数据的接口，用户只需要访问这个接口，而不需要知道具体的表的结构和表之间的关系。
　　数据库的结构和设计不会受到视图中的函数、where、join语句的影响。&lt;/p&gt;

&lt;h1 id=&#34;视图的优点和使用规则-http-www-cnblogs-com-careyson-archive-2011-12-07-2279522-html&#34;&gt;&lt;a href=&#34;http://www.cnblogs.com/CareySon/archive/2011/12/07/2279522.html&#34;&gt;视图的优点和使用规则&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&#34;为什么要使用视图&#34;&gt;为什么要使用视图&lt;/h2&gt;

&lt;p&gt;•   视图隐藏了底层的表结构，简化了数据访问操作
•   因为隐藏了底层的表结构，所以大大加强了安全性，用户只能看到视图提供的数据
•   使用视图，方便了权限管理，让用户对视图有权限而不是对底层表有权限进一步加强了安全性
•   视图提供了一个用户访问的接口，当底层表改变后，改变视图的语句来进行适应，使已经建立在这个视图上客户端程序不受影响&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SQL Server表连接(Join)</title>
      <link>/database/sql-server%E8%A1%A8%E8%BF%9E%E6%8E%A5-join/</link>
      <pubDate>Mon, 20 Apr 2015 21:44:19 +0800</pubDate>
      
      <guid>/database/sql-server%E8%A1%A8%E8%BF%9E%E6%8E%A5-join/</guid>
      <description>&lt;p&gt;　　Join用于根据两个或多个表之间的关系，从这些表之间查找数据。
　　有时候我们为了方便管理会将业务分拆成多个表，表之间用“键(key)”连接，之间存在一定的关联，比如我们有会员表专门存储会员信息，有订单表存储订单信息，但是我们要知道那些会员订购了那些商品，就需要结合两张表去查找这些信息了。
　　
　　Join有四种用法：
　　1. inner join :内连接。能够找到两个或多个表中建立连接字段值相等的记录。没有匹配的行就不会列出。
　　2. left join :左连接。关键字前面是左表，后面是右表。&amp;ndash;左连接可以得到左表所有数据，即使右表没有匹配的行。如果建立关联的字段值在右表中不存在，那么右表的数据就以null值替换。
　　3. right join :右连接。关键字前面的表是左表，后面的表是右表。&amp;ndash;右连接可以得到右表所有数据，即使左表没有匹配的行。如果建立关联的字段值在右左表中不存在，那么左表的数据就以null值替换。
　　4. full join :可以得到左右连接的综合结果&amp;ndash;去重复&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SQL Server触发器</title>
      <link>/database/sql-server%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Thu, 16 Apr 2015 23:33:00 +0800</pubDate>
      
      <guid>/database/sql-server%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description>&lt;p&gt;　　&lt;/p&gt;

&lt;h1 id=&#34;1-什么是触发器&#34;&gt;1. 什么是触发器&lt;/h1&gt;

&lt;p&gt;　　触发器是一种特殊的存储过程，和存储过程不同的是，触发器是由事件被触发时自动进行调用的。
　　触发器的执行不是由程序调用，也不是手工启动，而是有事件来触发，比如当对一个表进行操作(insert、delete、update)是就会激活触发器执行。触发器常用于加强数据的完整性约束和业务规则。&lt;/p&gt;

&lt;h2 id=&#34;1-1-分类&#34;&gt;1.1. 分类&lt;/h2&gt;

&lt;p&gt;　　SQL Server包括了三种常规类型的触发器：DML触发器、DDL触发器和登录触发器。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SQL Server联合结果集(union)</title>
      <link>/database/sql-server%E8%81%94%E5%90%88%E7%BB%93%E6%9E%9C%E9%9B%86-union/</link>
      <pubDate>Fri, 10 Apr 2015 20:46:09 +0800</pubDate>
      
      <guid>/database/sql-server%E8%81%94%E5%90%88%E7%BB%93%E6%9E%9C%E9%9B%86-union/</guid>
      <description>&lt;p&gt;　　&lt;code&gt;union&lt;/code&gt;操作符用于合并另个或多个select(查询)语句的结果集。
　　在使用&lt;code&gt;union&lt;/code&gt;操作符时，要注意联合的select语句需要有相同的列、相似的数据类型、列的顺序要相同。&lt;/p&gt;

&lt;h1 id=&#34;union和union-all&#34;&gt;union和union all&lt;/h1&gt;

&lt;p&gt;★ &lt;code&gt;union&lt;/code&gt;默认去掉合并结果中重复的数据。
★ &lt;code&gt;union all&lt;/code&gt;可以保留重复的结果数据。&lt;/p&gt;

&lt;h1 id=&#34;语法&#34;&gt;语法&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;from&lt;/span&gt; table1_name
&lt;span style=&#34;color:#ff79c6&#34;&gt;union&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;union&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;all&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;from&lt;/span&gt; table2_name&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;union结果集中的列名总是等于第一条select语句的列名&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ASP.NET存储过程操作</title>
      <link>/csharp/asp-net%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 06 Apr 2015 17:21:22 +0800</pubDate>
      
      <guid>/csharp/asp-net%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;p&gt;原文地址：&lt;a href=&#34;http://www.cnblogs.com/libingql/archive/2010/05/02/1726104.html&#34;&gt;http://www.cnblogs.com/libingql/archive/2010/05/02/1726104.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　存储过程是存放在数据库服务器上的预先编译好的sql语句。使用存储过程，可以直接在数据库中存储并运行功能强大的任务。存储过程在第一应用程序执行时进行语法检查和编译，编译好的版本保存在高速缓存中。在执行重复任务时，存储过程可以提高性能和一致性。由于存储过程可以将一系列对数据库的操作放在数据库服务器上执行，因而可以降低Web服务器的负载，提高整个系统的性能。&lt;/p&gt;

&lt;h1 id=&#34;1-创建存储过程&#34;&gt;1. 、创建存储过程&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;USE Northwind
&lt;span style=&#34;color:#ff79c6&#34;&gt;GO&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;CREATE&lt;/span&gt; PROC [DBO].[GetOrdersByOrderDate]
    &lt;span style=&#34;color:#ff79c6&#34;&gt;@&lt;/span&gt;OrderDate DATETIME
&lt;span style=&#34;color:#ff79c6&#34;&gt;AS&lt;/span&gt;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;SELECT&lt;/span&gt;
        [OrderID],[CustomerID],[OrderDate]
    &lt;span style=&#34;color:#ff79c6&#34;&gt;FROM&lt;/span&gt;
        [Orders]
    &lt;span style=&#34;color:#ff79c6&#34;&gt;WHERE&lt;/span&gt;
        [OrderDate] &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;@&lt;/span&gt;OrderDate


USE Northwind
&lt;span style=&#34;color:#ff79c6&#34;&gt;GO&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;EXEC&lt;/span&gt; GetByOrderDate &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;1996-10-10 0:00:00&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>SQL Server事务</title>
      <link>/database/sql-server%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Wed, 01 Apr 2015 21:20:19 +0800</pubDate>
      
      <guid>/database/sql-server%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;h1 id=&#34;1-什么是事务&#34;&gt;1. 什么是事务&lt;/h1&gt;

&lt;p&gt;　　事务(Transaction)是访问并可能更新数据库中的各种数据项的一个程序执行单元。事务用来保持逻辑数据的一致性和可恢复性，避免错误操作引发不可挽回的损失。
　　事务由begin Transaction(事务开始)和end Transaction(事务结束)之间执行的全部成员构成。在关系型数据库中，事务是一条或多条SQL语句组成的。&lt;/p&gt;

&lt;h2 id=&#34;1-1-事务的特性&#34;&gt;1.1. 事务的特性&lt;/h2&gt;

&lt;p&gt;　　事务有四个属性：原子性、一致性、隔离性、持久性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>存储过程</title>
      <link>/csharp/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Thu, 26 Mar 2015 11:25:35 +0800</pubDate>
      
      <guid>/csharp/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;h1 id=&#34;1-什么是存储过程&#34;&gt;1. 什么是存储过程&lt;/h1&gt;

&lt;p&gt;　　调用&lt;a href=&#34;http://baike.baidu.com/link?url=c2abUFqhD2LK7x4of_AqDRsR9zA_O8N7DSr-IK1oY_7C8_0OxNX-3mVmBfbPpYo5yhMm8nUGydsNQV0NJ73EL_&#34;&gt;百度百科&lt;/a&gt;的解释:存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象，任何一个设计良好的数据库应用程序都应该用到存储过程。
　　简单来说，存储过程就像是c#中的&lt;strong&gt;方法&lt;/strong&gt;，该方法实现某一特定的功能，在需要的地方直接调用就行了。而且该方法还是单例的。
　　存储过程不仅仅是一组SQL语句的组合，存储过程和一般的SQL语句还是有区别的。
　　&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>数据库基本增删改查语句总结</title>
      <link>/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 25 Mar 2015 20:27:07 +0800</pubDate>
      
      <guid>/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93/</guid>
      <description>创建 create 创建数据库 1 2 3 4 5 6 7 8  create database MyDatabase on primary ( name=&amp;#39;MyDatabase_data&amp;#39;, filename=&amp;#39;D:\working software\sql Sever\MSSQL11.MSSQLSERVER\MSSQL\DATA\MyDatabase0301_data.mdf&amp;#39;, size=5MB, filegorwth=1MB )   创建日志 1 2 3 4 5 6 7  log on ( name=&amp;#39;MyDatabase_log&amp;#39;, filename=&amp;#39;D:\working software\sql Sever\MSSQL11.MSSQLSERVER\MSSQL\DATA\MyDatabase0301_data_log.ldf&amp;#39;, size=1MB, filegorwth=10% )   使用某个数据库 1  use MyDatabase   创建表 1 2 3 4 5 6 7 8 9 10  carate table Student ( StuId int identity(1,1) primary key, --主键，自增从1开始每次增加1  StuName nvarchar(10), StuGender char(2), StuAge int, StuChinese int, StuMath int, StuEnglish int )   增(三种方式) inster into  第一种  1  inster into Student(StuName.</description>
    </item>
    
    <item>
      <title>ASP.NET中的Url重写</title>
      <link>/csharp/asp-net%E4%B8%AD%E7%9A%84url%E9%87%8D%E5%86%99/</link>
      <pubDate>Wed, 11 Feb 2015 13:47:48 +0800</pubDate>
      
      <guid>/csharp/asp-net%E4%B8%AD%E7%9A%84url%E9%87%8D%E5%86%99/</guid>
      <description>&lt;h1 id=&#34;1-一-为了页面更有利于seo优化-url重写程序需要做出的不可缺少的手段之一&#34;&gt;1. 一. 为了页面更有利于seo优化，url重写程序需要做出的不可缺少的手段之一。&lt;/h1&gt;

&lt;h1 id=&#34;2-二-目前url重写最常见的两种方法有&#34;&gt;2. 二.目前url重写最常见的两种方法有：&lt;/h1&gt;

&lt;p&gt;　　1. 通过熟悉页面的内部执行流程，也就是asp.net请求管道中的相关知识点，进行url重写。
　　2. 通过使用微软提供的UrlRewriter.dll实现url重写（简单）；&lt;/p&gt;

&lt;h1 id=&#34;3-三-在请求管道中的第一个请求管道中拦截url并使其完成url重写功能&#34;&gt;3. 三、在请求管道中的第一个请求管道中拦截url并使其完成url重写功能：&lt;/h1&gt;

&lt;p&gt;　　1. 熟悉请求管道实现程序运行的全过程：
　　　　(1)：BeginRequest: 开始处理请求
　　　　(2)：AuthenticateRequest授权验证请求，获取用户授权信息
　　　　(3):PostAuthenticateRequest获取成功
　　　　(4): AunthorizeRequest 授权，一般来检查用户是否获得权限&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>文件流操作流程代码</title>
      <link>/csharp/%E6%96%87%E4%BB%B6%E6%B5%81%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Tue, 27 Jan 2015 15:24:33 +0800</pubDate>
      
      <guid>/csharp/%E6%96%87%E4%BB%B6%E6%B5%81%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;h1 id=&#34;使用filestream来读取数据&#34;&gt;使用FileStream来读取数据&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;16
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;17
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;18
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;19
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;20
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;21
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;22
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;23
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;24
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;25
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;26
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;27
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//FileStream StreamReader和StreamWriter
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//FileStream用来操作字节
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//使用FileStream来读取一个文本文件 IO
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#6272a4&#34;&gt;//1、创建FileStream对象
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//第一个参数用来指定操作文件的路径
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//第二个参数用来指定系统打开文件的方式
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//第三个参数用来指定我们要对数据的操作
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;            
&lt;span style=&#34;color:#ff79c6&#34;&gt;using&lt;/span&gt; (FileStream fsRead = &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; FileStream(&lt;span style=&#34;color:#f1fa8c&#34;&gt;@&amp;#34;C:\Users\SpringRain\Desktop\我是数据1.txt&amp;#34;&lt;/span&gt;, FileMode.OpenOrCreate, FileAccess.Read))
{

&lt;span style=&#34;color:#6272a4&#34;&gt;//2、设置缓冲区的大小 5M
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#8be9fd&#34;&gt;byte&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;[]&lt;/span&gt; buffer = &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;byte&lt;/span&gt;&lt;span style=&#34;color:#50fa7b&#34;&gt;[1024 * 1024 * 5]&lt;/span&gt;;

&lt;span style=&#34;color:#6272a4&#34;&gt;//3、开始读取数据
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; r = fsRead.Read(buffer, &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;, buffer.Length);

&lt;span style=&#34;color:#6272a4&#34;&gt;//4、去缓冲区中获得我们需要的数据
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; s = Encoding.Default.GetString(buffer, &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;, r);
     Console.WriteLine(s);

&lt;span style=&#34;color:#6272a4&#34;&gt;//5、释放资源 流所占用的资源GC不能释放 需要我么自己手动的释放  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//写在using里面就不许要我们自己去手动释放资源了
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#6272a4&#34;&gt;//fsRead.Dispose();
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#6272a4&#34;&gt;//fsRead.Close();
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;     Console.ReadKey();
} &lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>街角咖啡店</title>
      <link>/%E6%96%87%E9%9B%86/%E8%A1%97%E8%A7%92%E5%92%96%E5%95%A1%E5%BA%97/</link>
      <pubDate>Sun, 16 Nov 2014 22:50:42 +0800</pubDate>
      
      <guid>/%E6%96%87%E9%9B%86/%E8%A1%97%E8%A7%92%E5%92%96%E5%95%A1%E5%BA%97/</guid>
      <description>&lt;p&gt;　　新婚后不久她就和婆婆闹了一场别扭。本来是一件正常的小误会，但是没想到的是他竟然当着他母亲的面狠狠的骂了自己一顿。她觉得委屈极了，认为这是他和自己结婚后悔了，他不爱自己了。于是她赌气的离家出走，没有告诉任何人。&lt;/p&gt;

&lt;p&gt;　　在以前上大学的这座城市里漂泊了好几天，她并没有找到一份合适自己的工作，而且糟糕的是她匆忙中带来的银行卡只有几百块钱，再没有着落的话，别说住宿了吃饭都成了问题。莫名的孤独与害怕袭上心头，她越发的埋怨起他来。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>纪念我的火影</title>
      <link>/%E6%96%87%E9%9B%86/%E7%BA%AA%E5%BF%B5%E6%88%91%E7%9A%84%E7%81%AB%E5%BD%B1/</link>
      <pubDate>Sat, 08 Nov 2014 22:59:11 +0800</pubDate>
      
      <guid>/%E6%96%87%E9%9B%86/%E7%BA%AA%E5%BF%B5%E6%88%91%E7%9A%84%E7%81%AB%E5%BD%B1/</guid>
      <description>&lt;p&gt;　　不知道怎么下笔，却又感慨万千，就像是送别一个十几年的老朋友，面对面的时候却又把一肚子的话停在了心里，只是拍拍肩膀，当做了一腔的感伤。&lt;/p&gt;

&lt;p&gt;　　只是再也没有勇气去追逐一段十年的故事。虽然它不尽完美，却饱含了青春，又寄托了希望，一个故事的结束往往象征着另一段故事的开始，可是我却留在那段青春里面，害怕回想，却又渴望永久。&lt;/p&gt;

&lt;p&gt;　　好像突然触动了一根心弦，被颤音惊倒，这才知道时光已经过去多少年，又到了说再见的时候，就像这生活，永远在奔波，永远在离别，永远不会停下脚步说一句，我等你！&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>