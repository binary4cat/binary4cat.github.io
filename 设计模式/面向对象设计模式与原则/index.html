<!DOCTYPE html>



 <html class="no-js"> 
<head>
    <title>面向对象设计模式与原则  &middot; Haijd&#39;s Blog </title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="content-language" content="en-us" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="Haijd">
    <meta name="description" content="a coder.">
    <meta name="generator" content="Hugo 0.53" />

    <!-- Stylesheets -->
    <link rel="stylesheet" href="/css/smooth-scrollbar.css" />
    <link rel="stylesheet" type="text/css" href="/css/main.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/tomorrow.min.css" />
    

    <style>
        .posts li {
            visibility: hidden;
        }
    </style> 
</head>

<body>

    

    <header>
    <div class="h-wrap">
        
        <div class="typewriter">
            <h1 class="title"><a href="/">Haijd&#39;s Blog</a></h1>
        </div>
        
    </div>
</header>
    <div class="site-wrapper" id="full-wrapper">

        <section class="single-wrap">
            <article class="single-content" itemscope itemtype="//schema.org/BlogPosting">
                <div class="feat">
                    <h5 class="page-date">
                        <time datetime="" itemprop="datePublished">
                    10 January 2016
                   
                    </time>
                    </h5>
                </div>
                <h1 class="page-title" itemprop="name headline">面向对象设计模式与原则</h1>
                <br>
                
                <div>
                    
                    <img src="http://lorempixel.com/1000/500/technics/">
                    
                </div>
                
                <div>
                    <nav id="TableOfContents">
<ul>
<li><a href="#1-设计原则">1. 设计原则</a></li>
<li><a href="#2-从设计原则到设计模式">2. 从设计原则到设计模式</a></li>
</ul>
</nav>
                </div>
                <hr>
                <div itemprop="articleBody">
                    <blockquote>
<p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。  ————Chistopher Alexander</p>
</blockquote>

<p>　　设计模式描述了软件设计过程中一些常见问题的一般性解决方案。
　　面向对象设计模式描述了面向对象设计过程中、特定场景下、类与相互通信的对象之间常见的组织关系。</p>

<h1 id="1-设计原则">1. 设计原则</h1>

<p>　　<strong>单一职责原则</strong>(SRP Single Responsibility Principle)：
　　　　一个类应该仅有一个引起它变化的原因，一个类只干它应该干的事情。</p>

<p>　　<strong>开放封闭原则</strong>(OCP Open Closed Principle)：
　　　　类模块应该是可扩展的，但是不可修改；一个类一旦定型了，就不要去修改它，有变化时就去扩展它。比如在三层中，DAL层中我们在原先的SQL访问基础上需要增加对MySql的支持，不应该去修改原先的类，而是应该建立一个IDAL接口有，让实现该接口的子类去封装变化。</p>

<p>　　<strong>Liskov替换原则</strong>(LSP Liskov Substituion Principle)：
　　　　里氏替换原则。在父类出现的地方，都可以使用子类代替。</p>

<p>　　<strong>依赖倒置原则</strong>(DIP Dependency Inversion Principle)：
　　　　高层模块不应该依赖于低层模块，二者都应该依赖于*抽象*。父类应该不知道子类的存在，在使用的时候，要调用最高层的父类，而不是具体实现的子类。
　　　　抽象不应该依赖于实现细节，实现细节应该依赖于*抽象*。子类的实现应该是从父类抽象出来的，此时父类并不知道子类的存在，也不知道子类做了什么具体的实现。</p>

<p>　　<strong>接口隔离原则</strong>(ISP Interface Segregation Principle)：
　　　　不应该强迫客户程序依赖他们不用或者用不到的方法。只留给客户端需要的接口，不暴露其他客户端无需使用和知道的方法。
　　　　尽量应用专门(单一作用)的接口，而不是单一的总接口(抽象),接口应该面向用户，将依赖建立在最小的接口上。也就是接口实现的功能应该是单一的，不能让一个接口干一件以上的事情。</p>

<p>　　<strong>合成/聚合复用原则</strong>(CARP Composite/Aggregate Reuse Principle)：
　　　　在吸纳对象中聚合已有对象，使之成为新对象成员，从而通过操作这些对象达到复用的目的。
　　　　合成方式较继承方式更松散，所以应该少继承、多聚合。</p>

<p>　　<strong>迪米特法则</strong>(LoD Law of Demeter)：
　　　　又叫最小知识原则，指软件实体应该尽可能少的和其他软件实体发生相互作用。也就是一个类不要实现太多不相关的功能，和单一职责原则比较相似。</p>

<h1 id="2-从设计原则到设计模式">2. 从设计原则到设计模式</h1>

<p>　　1、<strong>针对接口编程，而不是针对实现编程</strong>：
　　　　客户无需知道所使用的对象的特定类型，只需要知道对象拥有客户所期望的接口。
　　　　假如有一个父类，三个子类继承他，这三个子类就是客户所期望的具体实现，如果让客户直接去接触这三个子类，这种设计是不好的。最好的方法是：让父类实现一个接口，让客户去接触这个接口，而不是具体的实现。</p>

<p>　　2、<strong>优先使用对象组合，而不是类继承</strong>：
　　　　类继承通常为“白箱复用”。对象组合通常为“黑箱复用”。继承在某种程度上破坏了封装性，子类父类耦合度高；而对象组合则只要求被组合的对象拥有良好定义的接口，耦合度低。</p>

<p>　　3、<strong>封装变化点</strong>：
　　　　使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良影响，从而实现层次间的松耦合。</p>

<p>　　4、<strong>使用重构得到模式</strong>：
　　　　*设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用，没有一步到位的设计模式。*敏捷软件开发实践提倡的“Reafactoring to Patterns(从重构到模式)”是目前公认的最好的使用设计模式的方法。
　　　　在现有的代码上重构，是最好的方法，没有一步到位的程序，只有不断完善的程序。从0不能直接到100，但是可以从0到1、从1到10……</p>
                </div>
                <div class="feat share">
                </div>

                <div id="disqus_thread"></div>
<script>
    

    

    (function() { 
        var d = document,
            s = d.createElement('script');

        s.src = 'https://HaijdBlog.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

            </article>
        </section>

        <footer>
	
	<small>Haijd</small>
	
</footer>
    </div>

    <div class="next-prev-arrows">
        
        <a rel="next" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-singleton/" id="next">
                &larr; <span class="nav-title nav-title-next">单例模式(Singleton)</span> 
            </a>  
    </div>

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="/js/scrollreveal.min.js"></script>
<script type='application/javascript' src='/js/smooth-scrollbar.js'></script>
<script src="/js/baffle.min.js"></script>
<script src="/js/main.js"></script>
 
</body>

</html>